# Generated @ 2020-08-12T08:02:54+03:00
# Command line:
#   /home/dian/.nimble/pkgs/nimterop-0.6.6/nimterop/toast --preprocess -m:c --recurse -TBOOL=bool,char16_t=cushort,UINT=cuint --noHeader --includeDirs+=/usr/include/gtk-3.0 --includeDirs+=/usr/include/glib-2.0 --includeDirs+=/usr/lib/glib-2.0/include --includeDirs+=/usr/include/pango-1.0 --includeDirs+=/usr/include/cairo --includeDirs+=/usr/include/gdk-pixbuf-2.0 --includeDirs+=/usr/include/atk-1.0 --includeDirs+=/usr/include/harfbuzz --exclude+=/usr/include/gtk-3.0 --exclude+=/usr/include/glib-2.0 --exclude+=/usr/lib/glib-2.0/include --exclude+=/usr/include/pango-1.0 --exclude+=/usr/include/cairo --exclude+=/usr/include/gdk-pixbuf-2.0 --exclude+=/usr/include/atk-1.0 --exclude+=/usr/include/harfbuzz --pnim --symOverride=KB_LEFTBRACKET,KB_RIGHTBRACKET,KB_NUMLOCK,SUBSCRIPTIONS_REQUEST,RRT_FORCE_DWORD,RT_DATA_FORCE_DWORD,RS_FORCE_DWORD,SCDOM_OK_NOT_HANDLED,SCDOM_OK,SCDOM_INVALID_HWND,SCDOM_INVALID_HANDLE,SCDOM_PASSIVE_HANDLE,SCDOM_INVALID_PARAMETER,SCDOM_OPERATION_FAILED,HELEMENT,GtkWidget,HWINDOW,SCITER_VALUE,RECT,LPRECT,LPCRECT,SCDOM_RESULT,SUBSCRIPTIONS_REQUEST --nim:/home/dian/Things/Nim/bin/nim --pluginSourcePath=/home/dian/.cache/nim/nimterop/cPlugins/nimterop_3333537963.nim /home/dian/Projects/nsciter/sdk/include/sciter-x.h -o /home/dian/Projects/nsciter/src/nsciter/sciwrap.nim

# const 'LINUX' has unsupported value 'typedef signed char BOOL;'
# const 'SC_CALLBACK' has unsupported value 'typedef struct tagRECT'
# const 'HWINDOW' skipped
# const 'HINSTANCE' has unsupported value 'LPVOID /**/'
# const 'LRESULT' has unsupported value 'long'
# const 'HDC' has unsupported value 'LPVOID /* cairo_t*/'
# const 'OBSOLETE' has unsupported value '__attribute__((deprecated))'
# const 'STDCALL' has unsupported value '__stdcall'
# const 'EXTERN_C' has unsupported value 'extern'
# const 'FLOAT_VALUE' has unsupported value 'double'
# const 'HAS_TISCRIPT' has unsupported value 'typedef VALUE SCITER_VALUE;'
# const 'SCDOM_RESULT' skipped
# const 'SCDOM_OK' skipped
# const 'SCDOM_INVALID_HWND' skipped
# const 'SCDOM_INVALID_HANDLE' skipped
# const 'SCDOM_PASSIVE_HANDLE' skipped
# const 'SCDOM_INVALID_PARAMETER' skipped
# const 'SCDOM_OPERATION_FAILED' skipped
# const 'SCDOM_OK_NOT_HANDLED' skipped
# proc 'som_asset_get_class' skipped - static inline procs cannot work with '--noHeader | -H'
# const 'SOM_VALUE' has unsupported value 'SCITER_VALUE'
# proc '_SAPI' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SAPI' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'gapi' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'rapi' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterClassName' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterVersion' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterDataReady' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterDataReadyAsync' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterLoadFile' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterLoadHtml' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetCallback' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetMasterCSS' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterAppendMasterCSS' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetCSS' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetMediaType' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetMediaVars' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetMinWidth' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetMinHeight' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCall' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterEval' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterUpdateWindow' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetOption' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetPPI' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetViewExpando' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGraphicsCaps' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetHomeURL' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCreateWindow' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'Sciter_UseElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'Sciter_UnuseElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetRootElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetFocusElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterFindElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetChildrenCount' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetNthChild' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetParentElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementHtmlCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementTextCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetElementText' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetAttributeCount' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetNthAttributeNameCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetNthAttributeValueCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetAttributeByNameCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetAttributeByName' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterClearAttributes' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementIndex' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementType' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementTypeCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetStyleAttributeCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetStyleAttribute' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementLocation' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterScrollToView' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterUpdateElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterRefreshElementArea' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetCapture' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterReleaseCapture' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementHwnd' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCombineURL' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSelectElements' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSelectElementsW' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSelectParent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSelectParentW' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetElementHtml' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementUID' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementByUID' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterShowPopup' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterShowPopupAt' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterHidePopup' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementState' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetElementState' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCreateElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCloneElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterInsertElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterDetachElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterDeleteElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetTimer' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterDetachEventHandler' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterAttachEventHandler' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterWindowAttachEventHandler' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterWindowDetachEventHandler' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSendEvent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterPostEvent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterFireEvent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCallBehaviorMethod' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterRequestElementData' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterHttpRequest' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetScrollInfo' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetScrollPos' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementIntrinsicWidths' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetElementIntrinsicHeight' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterIsElementVisible' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterIsElementEnabled' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSortElements' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSwapElements' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterTraverseUIEvent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCallScriptingMethod' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCallScriptingFunction' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterEvalElementScript' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterAttachHwndToElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterControlGetType' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetValue' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetValue' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetExpando' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterGetHighlightedElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetHighlightedElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeAddRef' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeRelease' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeCastFromElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeCastToElement' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeFirstChild' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeLastChild' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeNextSibling' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodePrevSibling' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeParent' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeNthChild' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeChildrenCount' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeType' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeGetText' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeSetText' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeInsert' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterNodeRemove' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCreateTextNode' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterCreateCommentNode' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueInit' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueClear' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueCompare' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueCopy' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueIsolate' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueType' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueStringData' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueStringDataSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueIntData' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueIntDataSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueInt64Data' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueInt64DataSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueFloatData' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueFloatDataSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueBinaryData' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueBinaryDataSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueElementsCount' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueNthElementValue' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueNthElementValueSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueNthElementKey' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueEnumElements' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueSetValueToKey' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueGetValueOfKey' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueToString' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueFromString' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueInvoke' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueNativeFunctorSet' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'ValueIsNativeFunctor' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterProcX' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterAtomValue' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterAtomNameCB' skipped - static inline procs cannot work with '--noHeader | -H'
# proc 'SciterSetGlobalAsset' skipped - static inline procs cannot work with '--noHeader | -H'
{.push hint[ConvFromXtoItselfNotNeeded]: off.}
import macros

macro defineEnum(typ: untyped): untyped =
  result = newNimNode(nnkStmtList)

  # Enum mapped to distinct cint
  result.add quote do:
    type `typ`* = distinct cint

  for i in ["+", "-", "*", "div", "mod", "shl", "shr", "or", "and", "xor", "<", "<=", "==", ">", ">="]:
    let
      ni = newIdentNode(i)
      typout = if i[0] in "<=>": newIdentNode("bool") else: typ # comparisons return bool
    if i[0] == '>': # cannot borrow `>` and `>=` from templates
      let
        nopp = if i.len == 2: newIdentNode("<=") else: newIdentNode("<")
      result.add quote do:
        proc `ni`*(x: `typ`, y: cint): `typout` = `nopp`(y, x)
        proc `ni`*(x: cint, y: `typ`): `typout` = `nopp`(y, x)
        proc `ni`*(x, y: `typ`): `typout` = `nopp`(y, x)
    else:
      result.add quote do:
        proc `ni`*(x: `typ`, y: cint): `typout` {.borrow.}
        proc `ni`*(x: cint, y: `typ`): `typout` {.borrow.}
        proc `ni`*(x, y: `typ`): `typout` {.borrow.}
    result.add quote do:
      proc `ni`*(x: `typ`, y: int): `typout` = `ni`(x, y.cint)
      proc `ni`*(x: int, y: `typ`): `typout` = `ni`(x.cint, y)

  let
    divop = newIdentNode("/")   # `/`()
    dlrop = newIdentNode("$")   # `$`()
    notop = newIdentNode("not") # `not`()
  result.add quote do:
    proc `divop`*(x, y: `typ`): `typ` = `typ`((x.float / y.float).cint)
    proc `divop`*(x: `typ`, y: cint): `typ` = `divop`(x, `typ`(y))
    proc `divop`*(x: cint, y: `typ`): `typ` = `divop`(`typ`(x), y)
    proc `divop`*(x: `typ`, y: int): `typ` = `divop`(x, y.cint)
    proc `divop`*(x: int, y: `typ`): `typ` = `divop`(x.cint, y)

    proc `dlrop`*(x: `typ`): string {.borrow.}
    proc `notop`*(x: `typ`): `typ` {.borrow.}


{.experimental: "codeReordering".}
defineEnum(GFX_LAYER)
defineEnum(REQUEST_RESULT)
defineEnum(REQUEST_RQ_TYPE)
defineEnum(SciterResourceType)
defineEnum(REQUEST_STATE)
defineEnum(VALUE_RESULT)
defineEnum(C_VALUE_TYPE)
defineEnum(VALUE_UNIT_TYPE)
defineEnum(VALUE_UNIT_TYPE_DATE)
defineEnum(VALUE_UNIT_TYPE_OBJECT) ## ```
                                  ##   Sciter or TIScript specific
                                  ## ```
defineEnum(VALUE_UNIT_UNDEFINED)
defineEnum(VALUE_UNIT_TYPE_STRING) ## ```
                                  ##   Sciter or TIScript specific
                                  ## ```
defineEnum(VALUE_STRING_CVT_TYPE)
defineEnum(ELEMENT_AREAS)
defineEnum(SCITER_SCROLL_FLAGS)
defineEnum(SET_ELEMENT_HTML)
defineEnum(ELEMENT_STATE_BITS)
defineEnum(REQUEST_TYPE)
defineEnum(CTL_TYPE)
defineEnum(NODE_TYPE)
defineEnum(NODE_INS_TARGET)
defineEnum(GRAPHIN_RESULT)
defineEnum(DRAW_PATH_MODE)
defineEnum(SCITER_LINE_JOIN_TYPE)
defineEnum(SCITER_LINE_CAP_TYPE)
defineEnum(SCITER_IMAGE_ENCODING)
defineEnum(som_passport_flags)
defineEnum(EVENT_GROUPS)      ## ```
                        ##   event groups.
                        ## ```
defineEnum(PHASE_MASK)
defineEnum(MOUSE_BUTTONS)
defineEnum(KEYBOARD_STATES)
defineEnum(INITIALIZATION_EVENTS)
defineEnum(SOM_EVENTS)
defineEnum(DRAGGING_TYPE)
defineEnum(MOUSE_EVENTS)
defineEnum(CURSOR_TYPE)
defineEnum(KEY_EVENTS)
defineEnum(FOCUS_EVENTS)      ## ```
                        ##   #HANDLE_FOCUS commands
                        ## ```
defineEnum(FOCUS_CMD_TYPE)
defineEnum(SCROLL_EVENTS)
defineEnum(SCROLL_SOURCE)
defineEnum(SCROLLBAR_PART)
defineEnum(GESTURE_CMD)
defineEnum(GESTURE_STATE)
defineEnum(GESTURE_TYPE_FLAGS)
defineEnum(EXCHANGE_CMD)
defineEnum(DD_MODES)
defineEnum(DRAW_EVENTS)
defineEnum(CONTENT_CHANGE_BITS)
defineEnum(BEHAVIOR_EVENTS)
defineEnum(CLICK_REASON)
defineEnum(EDIT_CHANGED_REASON)
defineEnum(BEHAVIOR_METHOD_IDENTIFIERS)
defineEnum(SC_LOAD_DATA_RETURN_CODES) ## ```
                                     ##   #SC_LOAD_DATA notification return codes
                                     ## ```
defineEnum(SCRIPT_RUNTIME_FEATURES)
defineEnum(SCITER_RT_OPTIONS)
defineEnum(SCITER_CREATE_WINDOW_FLAGS)
defineEnum(OUTPUT_SUBSYTEMS)
defineEnum(OUTPUT_SEVERITY)
defineEnum(SCITER_X_MSG_CODE) ## ```
                             ##   The Sciter Engine of Terra Informatica Software, Inc.
                             ##    http:sciter.com
                             ##   
                             ##    The code and information provided "as-is" without
                             ##    warranty of any kind, either expressed or implied.
                             ##   
                             ##    (C) 2003-2015, Terra Informatica Software, Inc.
                             ##    
                             ##     
                             ##    Sciter basic types, platform isolation declarations
                             ##    
                             ##     
                             ##    The Sciter Engine of Terra Informatica Software, Inc.
                             ##    http:sciter.com
                             ##    
                             ##    The code and information provided "as-is" without
                             ##    warranty of any kind, either expressed or implied.
                             ##    
                             ##    (C) 2003-2015, Terra Informatica Software, Inc.
                             ##    
                             ##      #SCITER_X_MSG_CODE message/function identifier
                             ## ```
defineEnum(SCITER_PAINT_TARGET_TYPE) ## ```
                                    ##   #SCITER_X_MSG_PAINT target identifier.
                                    ## ```
const
  SUBSCRIPTIONS_REQUEST* = (0xFFFFFFFF'i32).EVENT_GROUPS
  GFX_LAYER_GDI* = (1).GFX_LAYER
  GFX_LAYER_CG* = (1).GFX_LAYER ## ```
                             ##   Mac OS
                             ## ```
  GFX_LAYER_CAIRO* = (1).GFX_LAYER ## ```
                                ##   Mac OS
                                ## ```
  GFX_LAYER_WARP* = (2).GFX_LAYER ## ```
                               ##   GTK
                               ## ```
  GFX_LAYER_D2D_WARP* = (2).GFX_LAYER
  GFX_LAYER_D2D* = (3).GFX_LAYER
  GFX_LAYER_SKIA* = (4).GFX_LAYER
  GFX_LAYER_SKIA_OPENGL* = (5).GFX_LAYER
  GFX_LAYER_AUTO* = (0x0000FFFF).GFX_LAYER
  SCITER_DLL_NAME* = "libsciter-gtk.so"
  REQUEST_PANIC* = (-1).REQUEST_RESULT ## ```
                                    ##   e.g. not enough memory
                                    ## ```
  REQUEST_OK* = (0).REQUEST_RESULT ## ```
                                ##   e.g. not enough memory
                                ## ```
  REQUEST_BAD_PARAM* = (1).REQUEST_RESULT ## ```
                                       ##   bad parameter
                                       ## ```
  REQUEST_FAILURE* = (2).REQUEST_RESULT ## ```
                                     ##   operation failed, e.g. index out of bounds
                                     ## ```
  REQUEST_NOTSUPPORTED* = (3).REQUEST_RESULT ## ```
                                          ##   the platform does not support requested feature
                                          ## ```
  RRT_GET* = (1).REQUEST_RQ_TYPE
  RRT_POST* = (2).REQUEST_RQ_TYPE
  RRT_PUT* = (3).REQUEST_RQ_TYPE
  RRT_DELETE* = (4).REQUEST_RQ_TYPE
  RT_DATA_HTML* = (0).SciterResourceType
  RT_DATA_IMAGE* = (1).SciterResourceType
  RT_DATA_STYLE* = (2).SciterResourceType
  RT_DATA_CURSOR* = (3).SciterResourceType
  RT_DATA_SCRIPT* = (4).SciterResourceType
  RT_DATA_RAW* = (5).SciterResourceType
  RT_DATA_FONT* = (RT_DATA_RAW + 1).SciterResourceType
  RT_DATA_SOUND* = (RT_DATA_FONT + 1).SciterResourceType ## ```
                                                    ##   wav bytes
                                                    ## ```
  RS_PENDING* = (0).REQUEST_STATE
  RS_SUCCESS* = (1).REQUEST_STATE ## ```
                               ##   completed successfully
                               ## ```
  RS_FAILURE* = (2).REQUEST_STATE ## ```
                               ##   completed with failure
                               ## ```
  HV_OK_TRUE* = (-1).VALUE_RESULT
  HV_OK* = (0).VALUE_RESULT
  HV_BAD_PARAMETER* = (1).VALUE_RESULT
  HV_INCOMPATIBLE_TYPE* = (2).VALUE_RESULT
  T_UNDEFINED* = (0).C_VALUE_TYPE
  T_NULL* = (1).C_VALUE_TYPE
  T_BOOL* = (2).C_VALUE_TYPE
  T_INT* = (3).C_VALUE_TYPE
  T_FLOAT* = (4).C_VALUE_TYPE
  T_STRING* = (5).C_VALUE_TYPE
  T_DATE* = (6).C_VALUE_TYPE ## ```
                          ##   INT64 - contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC), a.k.a. FILETIME on Windows
                          ## ```
  T_CURRENCY* = (7).C_VALUE_TYPE ## ```
                              ##   INT64 - 14.4 fixed number. E.g. dollars = int64 / 10000;
                              ## ```
  T_LENGTH* = (8).C_VALUE_TYPE ## ```
                            ##   length units, value is int or float, units are VALUE_UNIT_TYPE
                            ## ```
  T_ARRAY* = (9).C_VALUE_TYPE ## ```
                           ##   length units, value is int or float, units are VALUE_UNIT_TYPE
                           ## ```
  T_MAP* = (10).C_VALUE_TYPE
  T_FUNCTION* = (11).C_VALUE_TYPE ## ```
                               ##   named tuple , like array but with name tag
                               ## ```
  T_BYTES* = (12).C_VALUE_TYPE  ## ```
                            ##   sequence of bytes - e.g. image data
                            ## ```
  T_OBJECT* = (13).C_VALUE_TYPE ## ```
                             ##   scripting object proxy (TISCRIPT/SCITER)
                             ##     T_DOM_OBJECT = 14,   DOM object, use get_object_data to get HELEMENT
                             ## ```
  T_RESOURCE* = (15).C_VALUE_TYPE ## ```
                               ##   15 - other thing derived from tool::resource
                               ##     T_RANGE = 16,      16 - N..M, integer range.
                               ## ```
  T_DURATION* = (17).C_VALUE_TYPE ## ```
                               ##   double, seconds
                               ## ```
  T_ANGLE* = (18).C_VALUE_TYPE  ## ```
                            ##   double, radians
                            ## ```
  T_COLOR* = (19).C_VALUE_TYPE  ## ```
                            ##   [unsigned] INT, ABGR
                            ## ```
  T_ASSET* = (21).C_VALUE_TYPE  ## ```
                            ##   sciter::om::iasset* add_ref'ed pointer
                            ## ```
  UT_EM* = (1).VALUE_UNIT_TYPE  ## ```
                            ##   height of the element's font.
                            ## ```
  UT_EX* = (2).VALUE_UNIT_TYPE  ## ```
                            ##   height of letter 'x'
                            ## ```
  UT_PR* = (3).VALUE_UNIT_TYPE  ## ```
                            ##   %
                            ## ```
  UT_SP* = (4).VALUE_UNIT_TYPE  ## ```
                            ##   %% "springs", a.k.a. flex units
                            ## ```
  reserved1* = (5).VALUE_UNIT_TYPE ## ```
                                ##   %% "springs", a.k.a. flex units
                                ## ```
  reserved2* = (6).VALUE_UNIT_TYPE
  UT_PX* = (7).VALUE_UNIT_TYPE  ## ```
                            ##   pixels
                            ## ```
  UT_IN* = (8).VALUE_UNIT_TYPE  ## ```
                            ##   inches (1 inch = 2.54 centimeters).
                            ## ```
  UT_CM* = (9).VALUE_UNIT_TYPE  ## ```
                            ##   centimeters.
                            ## ```
  UT_MM* = (10).VALUE_UNIT_TYPE ## ```
                             ##   millimeters.
                             ## ```
  UT_PT* = (11).VALUE_UNIT_TYPE ## ```
                             ##   points (1 point = 1/72 inches).
                             ## ```
  UT_PC* = (12).VALUE_UNIT_TYPE ## ```
                             ##   picas (1 pica = 12 points).
                             ## ```
  UT_DIP* = (13).VALUE_UNIT_TYPE ## ```
                              ##   picas (1 pica = 12 points).
                              ## ```
  reserved3* = (14).VALUE_UNIT_TYPE
  reserved4* = (15).VALUE_UNIT_TYPE
  UT_URL* = (16).VALUE_UNIT_TYPE ## ```
                              ##   url in string
                              ## ```
  DT_HAS_DATE* = (0x00000001).VALUE_UNIT_TYPE_DATE ## ```
                                                ##   date contains date portion
                                                ## ```
  DT_HAS_TIME* = (0x00000002).VALUE_UNIT_TYPE_DATE ## ```
                                                ##   date contains time portion HH:MM
                                                ## ```
  DT_HAS_SECONDS* = (0x00000004).VALUE_UNIT_TYPE_DATE ## ```
                                                   ##   date contains time and seconds HH:MM:SS
                                                   ## ```
  DT_UTC* = (0x00000010).VALUE_UNIT_TYPE_DATE ## ```
                                           ##   T_DATE is known to be UTC. Otherwise it is local date/time
                                           ## ```
  UT_OBJECT_ARRAY* = (0).VALUE_UNIT_TYPE_OBJECT ## ```
                                             ##   type T_OBJECT of type Array
                                             ## ```
  UT_OBJECT_OBJECT* = (1).VALUE_UNIT_TYPE_OBJECT ## ```
                                              ##   type T_OBJECT of type Object
                                              ## ```
  UT_OBJECT_CLASS* = (2).VALUE_UNIT_TYPE_OBJECT ## ```
                                             ##   type T_OBJECT of type Class (class or namespace)
                                             ## ```
  UT_OBJECT_NATIVE* = (3).VALUE_UNIT_TYPE_OBJECT ## ```
                                              ##   type T_OBJECT of native Type with data slot (LPVOID)
                                              ## ```
  UT_OBJECT_FUNCTION* = (4).VALUE_UNIT_TYPE_OBJECT ## ```
                                                ##   type T_OBJECT of type Function
                                                ## ```
  UT_OBJECT_ERROR* = (5).VALUE_UNIT_TYPE_OBJECT ## ```
                                             ##   type T_OBJECT of type Error
                                             ## ```
  UT_NOTHING* = (1).VALUE_UNIT_UNDEFINED ## ```
                                      ##   T_UNDEFINED && UT_NOTHING -  'nothing' a.k.a. 'void' value in script
                                      ## ```
  UT_STRING_STRING* = (0).VALUE_UNIT_TYPE_STRING ## ```
                                              ##   string
                                              ## ```
  UT_STRING_ERROR* = (1).VALUE_UNIT_TYPE_STRING ## ```
                                             ##   is an error string
                                             ## ```
  UT_STRING_SECURE* = (2).VALUE_UNIT_TYPE_STRING ## ```
                                              ##   secure string ("wiped" on destroy)
                                              ## ```
  UT_STRING_SYMBOL* = (0x0000FFFF).VALUE_UNIT_TYPE_STRING ## ```
                                                       ##   symbol in tiscript sense
                                                       ## ```
  CVT_SIMPLE* = (0).VALUE_STRING_CVT_TYPE ## ```
                                       ##   /< simple conversion of terminal values
                                       ## ```
  CVT_JSON_LITERAL* = (CVT_SIMPLE + 1).VALUE_STRING_CVT_TYPE ## ```
                                                        ##   /< json literal parsing/emission
                                                        ## ```
  CVT_JSON_MAP* = (CVT_JSON_LITERAL + 1).VALUE_STRING_CVT_TYPE ## ```
                                                          ##   /< json parsing/emission, it parses as if token '{' already recognized
                                                          ## ```
  CVT_XJSON_LITERAL* = (CVT_JSON_MAP + 1).VALUE_STRING_CVT_TYPE ## ```
                                                           ##   /< x-json parsing/emission, date is emitted as ISO8601 date literal, currency is emitted in the form DDDD$CCC
                                                           ## ```
  ROOT_RELATIVE* = (0x00000001).ELEMENT_AREAS ## ```
                                           ##   - or this flag if you want to get Sciter window relative coordinates,
                                           ##        otherwise it will use nearest windowed container e.g. popup window.
                                           ## ```
  SELF_RELATIVE* = (0x00000002).ELEMENT_AREAS ## ```
                                           ##   - "or" this flag if you want to get coordinates relative to the origin
                                           ##        of element iself.
                                           ## ```
  CONTAINER_RELATIVE* = (0x00000003).ELEMENT_AREAS ## ```
                                                ##   - position inside immediate container.
                                                ## ```
  VIEW_RELATIVE* = (0x00000004).ELEMENT_AREAS ## ```
                                           ##   - position relative to view - Sciter window
                                           ## ```
  CONTENT_BOX* = (0x00000000).ELEMENT_AREAS ## ```
                                         ##   content (inner)  box
                                         ## ```
  PADDING_BOX* = (0x00000010).ELEMENT_AREAS ## ```
                                         ##   content + paddings
                                         ## ```
  BORDER_BOX* = (0x00000020).ELEMENT_AREAS ## ```
                                        ##   content + paddings + border
                                        ## ```
  MARGIN_BOX* = (0x00000030).ELEMENT_AREAS ## ```
                                        ##   content + paddings + border + margins
                                        ## ```
  BACK_IMAGE_AREA* = (0x00000040).ELEMENT_AREAS ## ```
                                             ##   relative to content origin - location of background image (if it set no-repeat)
                                             ## ```
  FORE_IMAGE_AREA* = (0x00000050).ELEMENT_AREAS ## ```
                                             ##   relative to content origin - location of foreground image (if it set no-repeat)
                                             ## ```
  SCROLLABLE_AREA* = (0x00000060).ELEMENT_AREAS ## ```
                                             ##   scroll_area - scrollable area in content box
                                             ## ```
  SCROLL_TO_TOP* = (0x00000001).SCITER_SCROLL_FLAGS
  SCROLL_SMOOTH* = (0x00000010).SCITER_SCROLL_FLAGS
  SIH_REPLACE_CONTENT* = (0).SET_ELEMENT_HTML
  SIH_INSERT_AT_START* = (1).SET_ELEMENT_HTML
  SIH_APPEND_AFTER_LAST* = (2).SET_ELEMENT_HTML
  SOH_REPLACE* = (3).SET_ELEMENT_HTML
  SOH_INSERT_BEFORE* = (4).SET_ELEMENT_HTML
  SOH_INSERT_AFTER* = (5).SET_ELEMENT_HTML
  STATE_LINK* = (0x00000001).ELEMENT_STATE_BITS
  STATE_HOVER* = (0x00000002).ELEMENT_STATE_BITS
  STATE_ACTIVE* = (0x00000004).ELEMENT_STATE_BITS
  STATE_FOCUS* = (0x00000008).ELEMENT_STATE_BITS
  STATE_VISITED* = (0x00000010).ELEMENT_STATE_BITS
  STATE_CURRENT* = (0x00000020).ELEMENT_STATE_BITS ## ```
                                                ##   current (hot) item
                                                ## ```
  STATE_CHECKED* = (0x00000040).ELEMENT_STATE_BITS ## ```
                                                ##   element is checked (or selected)
                                                ## ```
  STATE_DISABLED* = (0x00000080).ELEMENT_STATE_BITS ## ```
                                                 ##   element is disabled
                                                 ## ```
  STATE_READONLY* = (0x00000100).ELEMENT_STATE_BITS ## ```
                                                 ##   readonly input element
                                                 ## ```
  STATE_EXPANDED* = (0x00000200).ELEMENT_STATE_BITS ## ```
                                                 ##   expanded state - nodes in tree view
                                                 ## ```
  STATE_COLLAPSED* = (0x00000400).ELEMENT_STATE_BITS ## ```
                                                  ##   collapsed state - nodes in tree view - mutually exclusive with
                                                  ## ```
  STATE_INCOMPLETE* = (0x00000800).ELEMENT_STATE_BITS ## ```
                                                   ##   one of fore/back images requested but not delivered
                                                   ## ```
  STATE_ANIMATING* = (0x00001000).ELEMENT_STATE_BITS ## ```
                                                  ##   is animating currently
                                                  ## ```
  STATE_FOCUSABLE* = (0x00002000).ELEMENT_STATE_BITS ## ```
                                                  ##   will accept focus
                                                  ## ```
  STATE_ANCHOR* = (0x00004000).ELEMENT_STATE_BITS ## ```
                                               ##   anchor in selection (used with current in selects)
                                               ## ```
  STATE_SYNTHETIC* = (0x00008000).ELEMENT_STATE_BITS ## ```
                                                  ##   this is a synthetic element - don't emit it's head/tail
                                                  ## ```
  STATE_OWNS_POPUP* = (0x00010000).ELEMENT_STATE_BITS ## ```
                                                   ##   this is a synthetic element - don't emit it's head/tail
                                                   ## ```
  STATE_TABFOCUS* = (0x00020000).ELEMENT_STATE_BITS ## ```
                                                 ##   focus gained by tab traversal
                                                 ## ```
  STATE_EMPTY* = (0x00040000).ELEMENT_STATE_BITS ## ```
                                              ##   empty - element is empty (text.size() == 0 && subs.size() == 0)
                                              ##       if element has behavior attached then the behavior is responsible for the value of this flag.
                                              ## ```
  STATE_BUSY* = (0x00080000).ELEMENT_STATE_BITS ## ```
                                             ##   busy; loading
                                             ## ```
  STATE_DRAG_OVER* = (0x00100000).ELEMENT_STATE_BITS ## ```
                                                  ##   drag over the block that can accept it (so is current drop target). Flag is set for the drop target block
                                                  ## ```
  STATE_DROP_TARGET* = (0x00200000).ELEMENT_STATE_BITS ## ```
                                                    ##   active drop target.
                                                    ## ```
  STATE_MOVING* = (0x00400000).ELEMENT_STATE_BITS ## ```
                                               ##   dragging/moving - the flag is set for the moving block.
                                               ## ```
  STATE_COPYING* = (0x00800000).ELEMENT_STATE_BITS ## ```
                                                ##   dragging/copying - the flag is set for the copying block.
                                                ## ```
  STATE_DRAG_SOURCE* = (0x01000000).ELEMENT_STATE_BITS ## ```
                                                    ##   element that is a drag source.
                                                    ## ```
  STATE_DROP_MARKER* = (0x02000000).ELEMENT_STATE_BITS ## ```
                                                    ##   element is drop marker
                                                    ## ```
  STATE_PRESSED* = (0x04000000).ELEMENT_STATE_BITS ## ```
                                                ##   pressed - close to active but has wider life span - e.g. in MOUSE_UP it
                                                ##        is still on; so behavior can check it in MOUSE_UP to discover CLICK condition.
                                                ## ```
  STATE_POPUP* = (0x08000000).ELEMENT_STATE_BITS ## ```
                                              ##   this element is out of flow - popup
                                              ## ```
  STATE_IS_LTR* = (0x10000000).ELEMENT_STATE_BITS ## ```
                                               ##   the element or one of its containers has dir=ltr declared
                                               ## ```
  STATE_IS_RTL* = (0x20000000).ELEMENT_STATE_BITS ## ```
                                               ##   the element or one of its containers has dir=rtl declared
                                               ## ```
  GET_ASYNC* = (0).REQUEST_TYPE ## ```
                             ##   async GET
                             ## ```
  POST_ASYNC* = (GET_ASYNC + 1).REQUEST_TYPE ## ```
                                        ##   async POST
                                        ## ```
  GET_SYNC* = (POST_ASYNC + 1).REQUEST_TYPE ## ```
                                       ##   synchronous GET
                                       ## ```
  POST_SYNC* = (GET_SYNC + 1).REQUEST_TYPE ## ```
                                      ##   synchronous POST
                                      ## ```
  CTL_NO* = (0).CTL_TYPE        ## ```
                      ##   /< This dom element has no behavior at all.
                      ## ```
  CTL_UNKNOWN* = (1).CTL_TYPE ## ```
                           ##   /< This dom element has behavior but its type is unknown.
                           ## ```
  CTL_EDIT* = (2).CTL_TYPE      ## ```
                        ##   /< Single line edit box.
                        ## ```
  CTL_NUMERIC* = (3).CTL_TYPE   ## ```
                           ##   /< Numeric input with optional spin buttons.
                           ## ```
  CTL_CLICKABLE* = (4).CTL_TYPE ## ```
                             ##   /< toolbar button, behavior:clickable.
                             ## ```
  CTL_BUTTON* = (5).CTL_TYPE    ## ```
                          ##   /< Command button.
                          ## ```
  CTL_CHECKBOX* = (6).CTL_TYPE  ## ```
                            ##   /< CheckBox (button).
                            ## ```
  CTL_RADIO* = (7).CTL_TYPE     ## ```
                         ##   /< OptionBox (button).
                         ## ```
  CTL_SELECT_SINGLE* = (8).CTL_TYPE ## ```
                                 ##   /< Single select, ListBox or TreeView.
                                 ## ```
  CTL_SELECT_MULTIPLE* = (9).CTL_TYPE ## ```
                                   ##   /< Multiselectable select, ListBox or TreeView.
                                   ## ```
  CTL_DD_SELECT* = (10).CTL_TYPE ## ```
                              ##   /< Dropdown single select.
                              ## ```
  CTL_TEXTAREA* = (11).CTL_TYPE ## ```
                             ##   /< Multiline TextBox.
                             ## ```
  CTL_HTMLAREA* = (12).CTL_TYPE ## ```
                             ##   /< HTML selection behavior.
                             ## ```
  CTL_PASSWORD* = (13).CTL_TYPE ## ```
                             ##   /< Password input element.
                             ## ```
  CTL_PROGRESS* = (14).CTL_TYPE ## ```
                             ##   /< Progress element.
                             ## ```
  CTL_SLIDER* = (15).CTL_TYPE   ## ```
                           ##   /< Slider input element.
                           ## ```
  CTL_DECIMAL* = (16).CTL_TYPE  ## ```
                            ##   /< Decimal number input element.
                            ## ```
  CTL_CURRENCY* = (17).CTL_TYPE ## ```
                             ##   /< Currency input element.
                             ## ```
  CTL_SCROLLBAR* = (18).CTL_TYPE ## ```
                              ##   /< Currency input element.
                              ## ```
  CTL_LIST* = (19).CTL_TYPE
  CTL_RICHTEXT* = (20).CTL_TYPE
  CTL_CALENDAR* = (21).CTL_TYPE
  CTL_DATE* = (22).CTL_TYPE
  CTL_TIME* = (23).CTL_TYPE
  CTL_FILE* = (24).CTL_TYPE     ## ```
                         ##   /< file input element.
                         ## ```
  CTL_PATH* = (25).CTL_TYPE     ## ```
                         ##   /< path input element.
                         ## ```
  CTL_LAST_INPUT* = (26).CTL_TYPE
  CTL_HYPERLINK* = (CTL_LAST_INPUT).CTL_TYPE
  CTL_FORM* = (27).CTL_TYPE
  CTL_MENUBAR* = (28).CTL_TYPE
  CTL_MENU* = (29).CTL_TYPE
  CTL_MENUBUTTON* = (30).CTL_TYPE
  CTL_FRAME* = (31).CTL_TYPE
  CTL_FRAMESET* = (32).CTL_TYPE
  CTL_TOOLTIP* = (33).CTL_TYPE
  CTL_HIDDEN* = (34).CTL_TYPE
  CTL_URL* = (35).CTL_TYPE      ## ```
                        ##   /< URL input element.
                        ## ```
  CTL_TOOLBAR* = (36).CTL_TYPE  ## ```
                            ##   /< URL input element.
                            ## ```
  CTL_WINDOW* = (37).CTL_TYPE   ## ```
                           ##   /< has HWND attached to it
                           ## ```
  CTL_LABEL* = (38).CTL_TYPE
  CTL_IMAGE* = (39).CTL_TYPE    ## ```
                          ##   /< image/video object.
                          ## ```
  CTL_PLAINTEXT* = (40).CTL_TYPE ## ```
                              ##   /< Multiline TextBox + colorizer.
                              ## ```
  NT_ELEMENT* = (0).NODE_TYPE
  NT_TEXT* = (NT_ELEMENT + 1).NODE_TYPE
  NT_COMMENT* = (NT_TEXT + 1).NODE_TYPE
  NIT_BEFORE* = (0).NODE_INS_TARGET
  NIT_AFTER* = (NIT_BEFORE + 1).NODE_INS_TARGET
  NIT_APPEND* = (NIT_AFTER + 1).NODE_INS_TARGET
  NIT_PREPEND* = (NIT_APPEND + 1).NODE_INS_TARGET
  GRAPHIN_PANIC* = (-1).GRAPHIN_RESULT ## ```
                                    ##   e.g. not enough memory
                                    ## ```
  GRAPHIN_OK* = (0).GRAPHIN_RESULT ## ```
                                ##   e.g. not enough memory
                                ## ```
  GRAPHIN_BAD_PARAM* = (1).GRAPHIN_RESULT ## ```
                                       ##   bad parameter
                                       ## ```
  GRAPHIN_FAILURE* = (2).GRAPHIN_RESULT ## ```
                                     ##   operation failed, e.g. restore() without save()
                                     ## ```
  GRAPHIN_NOTSUPPORTED* = (3).GRAPHIN_RESULT ## ```
                                          ##   the platform does not support requested feature
                                          ## ```
  DRAW_FILL_ONLY* = (1).DRAW_PATH_MODE
  DRAW_STROKE_ONLY* = (2).DRAW_PATH_MODE
  DRAW_FILL_AND_STROKE* = (3).DRAW_PATH_MODE
  SCITER_JOIN_MITER* = (0).SCITER_LINE_JOIN_TYPE
  SCITER_JOIN_ROUND* = (1).SCITER_LINE_JOIN_TYPE
  SCITER_JOIN_BEVEL* = (2).SCITER_LINE_JOIN_TYPE
  SCITER_JOIN_MITER_OR_BEVEL* = (3).SCITER_LINE_JOIN_TYPE
  SCITER_LINE_CAP_BUTT* = (0).SCITER_LINE_CAP_TYPE
  SCITER_LINE_CAP_SQUARE* = (1).SCITER_LINE_CAP_TYPE
  SCITER_LINE_CAP_ROUND* = (2).SCITER_LINE_CAP_TYPE
  SCITER_IMAGE_ENCODING_RAW* = (0).SCITER_IMAGE_ENCODING ## ```
                                                      ##   [a,b,g,r,a,b,g,r,...] vector
                                                      ## ```
  SCITER_IMAGE_ENCODING_PNG* = (SCITER_IMAGE_ENCODING_RAW + 1).SCITER_IMAGE_ENCODING ## ```
                                                                                ##   [a,b,g,r,a,b,g,r,...] vector
                                                                                ## ```
  SCITER_IMAGE_ENCODING_JPG* = (SCITER_IMAGE_ENCODING_PNG + 1).SCITER_IMAGE_ENCODING
  SCITER_IMAGE_ENCODING_WEBP* = (SCITER_IMAGE_ENCODING_JPG + 1).SCITER_IMAGE_ENCODING
  SOM_SEALED_OBJECT* = (0x00000000).som_passport_flags ## ```
                                                    ##   not extendable
                                                    ## ```
  SOM_EXTENDABLE_OBJECT* = (0x00000001).som_passport_flags ## ```
                                                        ##   extendable, asset may have new properties added
                                                        ## ```
  HANDLE_INITIALIZATION* = (0x00000000).EVENT_GROUPS ## ```
                                                  ##   < attached/detached
                                                  ## ```
  HANDLE_MOUSE* = (0x00000001).EVENT_GROUPS ## ```
                                         ##   < mouse events
                                         ## ```
  HANDLE_KEY* = (0x00000002).EVENT_GROUPS ## ```
                                       ##   < key events
                                       ## ```
  HANDLE_FOCUS* = (0x00000004).EVENT_GROUPS ## ```
                                         ##   < focus events, if this flag is set it also means that element it attached to is focusable
                                         ## ```
  HANDLE_SCROLL* = (0x00000008).EVENT_GROUPS ## ```
                                          ##   < scroll events
                                          ## ```
  HANDLE_TIMER* = (0x00000010).EVENT_GROUPS ## ```
                                         ##   < timer event
                                         ## ```
  HANDLE_SIZE* = (0x00000020).EVENT_GROUPS ## ```
                                        ##   < size changed event
                                        ## ```
  HANDLE_DRAW* = (0x00000040).EVENT_GROUPS ## ```
                                        ##   < drawing request (event)
                                        ## ```
  HANDLE_DATA_ARRIVED* = (0x00000080).EVENT_GROUPS ## ```
                                                ##   < requested data () has been delivered
                                                ## ```
  HANDLE_BEHAVIOR_EVENT* = (0x00000100).EVENT_GROUPS ## ```
                                                  ##   < logical, synthetic events:
                                                  ##                                                    BUTTON_CLICK, HYPERLINK_CLICK, etc.,
                                                  ##                                                    a.k.a. notifications from intrinsic behaviors
                                                  ## ```
  HANDLE_METHOD_CALL* = (0x00000200).EVENT_GROUPS ## ```
                                               ##   < behavior specific methods
                                               ## ```
  HANDLE_SCRIPTING_METHOD_CALL* = (0x00000400).EVENT_GROUPS ## ```
                                                         ##   < behavior specific methods 
                                                         ##     HANDLE_TISCRIPT_METHOD_CALL  = 0x0800, < behavior specific methods using direct tiscript::value's
                                                         ## ```
  HANDLE_EXCHANGE* = (0x00001000).EVENT_GROUPS ## ```
                                            ##   < system drag-n-drop
                                            ## ```
  HANDLE_GESTURE* = (0x00002000).EVENT_GROUPS ## ```
                                           ##   < touch input events
                                           ## ```
  HANDLE_SOM* = (0x00008000).EVENT_GROUPS ## ```
                                       ##   < som_asset_t request
                                       ## ```
  HANDLE_ALL* = (0x0000FFFF).EVENT_GROUPS ## ```
                                       ##   < all of them
                                       ## ```
  BUBBLING* = (0).PHASE_MASK    ## ```
                          ##   bubbling (emersion) phase
                          ## ```
  SINKING* = (0x00008000).PHASE_MASK ## ```
                                  ##   capture (immersion) phase, this flag is or'ed with EVENTS codes below
                                  ## ```
  HANDLED* = (0x00010000).PHASE_MASK ## ```
                                  ##   capture (immersion) phase, this flag is or'ed with EVENTS codes below
                                  ## ```
  MAIN_MOUSE_BUTTON* = (1).MOUSE_BUTTONS ## ```
                                      ##   aka left button
                                      ## ```
  PROP_MOUSE_BUTTON* = (2).MOUSE_BUTTONS ## ```
                                      ##   aka right button
                                      ## ```
  MIDDLE_MOUSE_BUTTON* = (4).MOUSE_BUTTONS ## ```
                                        ##   aka right button
                                        ## ```
  CONTROL_KEY_PRESSED* = (0x00000001).KEYBOARD_STATES
  SHIFT_KEY_PRESSED* = (0x00000002).KEYBOARD_STATES
  ALT_KEY_PRESSED* = (0x00000004).KEYBOARD_STATES
  BEHAVIOR_DETACH* = (0).INITIALIZATION_EVENTS
  BEHAVIOR_ATTACH* = (1).INITIALIZATION_EVENTS
  SOM_GET_PASSPORT* = (0).SOM_EVENTS
  SOM_GET_ASSET* = (1).SOM_EVENTS
  NO_DRAGGING* = (0).DRAGGING_TYPE
  DRAGGING_MOVE* = (NO_DRAGGING + 1).DRAGGING_TYPE
  DRAGGING_COPY* = (DRAGGING_MOVE + 1).DRAGGING_TYPE
  MOUSE_ENTER* = (0).MOUSE_EVENTS
  MOUSE_LEAVE* = (MOUSE_ENTER + 1).MOUSE_EVENTS
  MOUSE_MOVE* = (MOUSE_LEAVE + 1).MOUSE_EVENTS
  MOUSE_UP* = (MOUSE_MOVE + 1).MOUSE_EVENTS
  MOUSE_DOWN* = (MOUSE_UP + 1).MOUSE_EVENTS
  MOUSE_DCLICK* = (MOUSE_DOWN + 1).MOUSE_EVENTS
  MOUSE_WHEEL* = (MOUSE_DCLICK + 1).MOUSE_EVENTS
  MOUSE_TICK* = (MOUSE_WHEEL + 1).MOUSE_EVENTS ## ```
                                          ##   mouse pressed ticks
                                          ## ```
  MOUSE_IDLE* = (MOUSE_TICK + 1).MOUSE_EVENTS ## ```
                                         ##   mouse stay idle for some time
                                         ## ```
  DROP* = (9).MOUSE_EVENTS      ## ```
                        ##   item dropped, target is that dropped item
                        ## ```
  DRAG_ENTER* = (0x0000000A).MOUSE_EVENTS ## ```
                                       ##   drag arrived to the target element that is one of current drop targets.
                                       ## ```
  DRAG_LEAVE* = (0x0000000B).MOUSE_EVENTS ## ```
                                       ##   drag left one of current drop targets. target is the drop target element.
                                       ## ```
  DRAG_REQUEST* = (0x0000000C).MOUSE_EVENTS ## ```
                                         ##   drag src notification before drag start. To cancel - return true from handler.
                                         ## ```
  MOUSE_CLICK* = (0x000000FF).MOUSE_EVENTS ## ```
                                        ##   mouse click event
                                        ## ```
  DRAGGING* = (0x00000100).MOUSE_EVENTS ## ```
                                     ##   This flag is 'ORed' with MOUSE_ENTER..MOUSE_DOWN codes if dragging operation is in effect.
                                     ##      E.g. event DRAGGING | MOUSE_MOVE is sent to underlying DOM elements while dragging.
                                     ## ```
  CURSOR_ARROW* = (0).CURSOR_TYPE ## ```
                               ##   0
                               ## ```
  CURSOR_IBEAM* = (CURSOR_ARROW + 1).CURSOR_TYPE ## ```
                                            ##   1
                                            ## ```
  CURSOR_WAIT* = (CURSOR_IBEAM + 1).CURSOR_TYPE ## ```
                                           ##   2
                                           ## ```
  CURSOR_CROSS* = (CURSOR_WAIT + 1).CURSOR_TYPE ## ```
                                           ##   3
                                           ## ```
  CURSOR_UPARROW* = (CURSOR_CROSS + 1).CURSOR_TYPE ## ```
                                              ##   4
                                              ## ```
  CURSOR_SIZENWSE* = (CURSOR_UPARROW + 1).CURSOR_TYPE ## ```
                                                 ##   5
                                                 ## ```
  CURSOR_SIZENESW* = (CURSOR_SIZENWSE + 1).CURSOR_TYPE ## ```
                                                  ##   6
                                                  ## ```
  CURSOR_SIZEWE* = (CURSOR_SIZENESW + 1).CURSOR_TYPE ## ```
                                                ##   7
                                                ## ```
  CURSOR_SIZENS* = (CURSOR_SIZEWE + 1).CURSOR_TYPE ## ```
                                              ##   8
                                              ## ```
  CURSOR_SIZEALL* = (CURSOR_SIZENS + 1).CURSOR_TYPE ## ```
                                               ##   9
                                               ## ```
  CURSOR_NO* = (CURSOR_SIZEALL + 1).CURSOR_TYPE ## ```
                                           ##   10
                                           ## ```
  CURSOR_APPSTARTING* = (CURSOR_NO + 1).CURSOR_TYPE ## ```
                                               ##   11
                                               ## ```
  CURSOR_HELP* = (CURSOR_APPSTARTING + 1).CURSOR_TYPE ## ```
                                                 ##   12
                                                 ## ```
  CURSOR_HAND* = (CURSOR_HELP + 1).CURSOR_TYPE ## ```
                                          ##   13
                                          ## ```
  CURSOR_DRAG_MOVE* = (CURSOR_HAND + 1).CURSOR_TYPE ## ```
                                               ##   14
                                               ## ```
  CURSOR_DRAG_COPY* = (CURSOR_DRAG_MOVE + 1).CURSOR_TYPE ## ```
                                                    ##   15
                                                    ## ```
  KEY_DOWN* = (0).KEY_EVENTS
  KEY_UP* = (KEY_DOWN + 1).KEY_EVENTS
  KEY_CHAR* = (KEY_UP + 1).KEY_EVENTS
  FOCUS_OUT* = (0).FOCUS_EVENTS ## ```
                             ##   < container lost focus from any element inside it, target is an element that lost focus
                             ## ```
  FOCUS_IN* = (1).FOCUS_EVENTS ## ```
                            ##   < container got focus on element inside it, target is an element that got focus
                            ## ```
  FOCUS_GOT* = (2).FOCUS_EVENTS ## ```
                             ##   < target element got focus
                             ## ```
  FOCUS_LOST* = (3).FOCUS_EVENTS ## ```
                              ##   < target element lost focus
                              ## ```
  FOCUS_REQUEST* = (4).FOCUS_EVENTS ## ```
                                 ##   < bubbling event/request, gets sent on child-parent chain to accept/reject focus to be set on the child (target)
                                 ## ```
  FOCUS_ADVANCE_REQUEST* = (5).FOCUS_EVENTS ## ```
                                         ##   < bubbling event/request, gets sent on child-parent chain to advance focus
                                         ## ```
  FOCUS_RQ_NEXT* = (0).FOCUS_CMD_TYPE
  FOCUS_RQ_PREV* = (FOCUS_RQ_NEXT + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_HOME* = (FOCUS_RQ_PREV + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_END* = (FOCUS_RQ_HOME + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_LEFT* = (FOCUS_RQ_END + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_RIGHT* = (FOCUS_RQ_LEFT + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_UP* = (FOCUS_RQ_RIGHT + 1).FOCUS_CMD_TYPE
  FOCUS_RQ_DOWN* = (FOCUS_RQ_UP + 1).FOCUS_CMD_TYPE ## ```
                                               ##   all these - by key
                                               ## ```
  FOCUS_RQ_FIRST* = (FOCUS_RQ_DOWN + 1).FOCUS_CMD_TYPE ## ```
                                                  ##   these two - by_code
                                                  ## ```
  FOCUS_RQ_LAST* = (FOCUS_RQ_FIRST + 1).FOCUS_CMD_TYPE ## ```
                                                  ##   
                                                  ## ```
  FOCUS_RQ_END_REACHED* = (0x00008000).FOCUS_CMD_TYPE ## ```
                                                   ##   
                                                   ## ```
  SCROLL_HOME* = (0).SCROLL_EVENTS
  SCROLL_END* = (SCROLL_HOME + 1).SCROLL_EVENTS
  SCROLL_STEP_PLUS* = (SCROLL_END + 1).SCROLL_EVENTS
  SCROLL_STEP_MINUS* = (SCROLL_STEP_PLUS + 1).SCROLL_EVENTS
  SCROLL_PAGE_PLUS* = (SCROLL_STEP_MINUS + 1).SCROLL_EVENTS
  SCROLL_PAGE_MINUS* = (SCROLL_PAGE_PLUS + 1).SCROLL_EVENTS
  SCROLL_POS* = (SCROLL_PAGE_MINUS + 1).SCROLL_EVENTS
  SCROLL_SLIDER_RELEASED* = (SCROLL_POS + 1).SCROLL_EVENTS
  SCROLL_CORNER_PRESSED* = (SCROLL_SLIDER_RELEASED + 1).SCROLL_EVENTS
  SCROLL_CORNER_RELEASED* = (SCROLL_CORNER_PRESSED + 1).SCROLL_EVENTS
  SCROLL_SLIDER_PRESSED* = (SCROLL_CORNER_RELEASED + 1).SCROLL_EVENTS
  SCROLL_SOURCE_UNKNOWN* = (0).SCROLL_SOURCE
  SCROLL_SOURCE_KEYBOARD* = (SCROLL_SOURCE_UNKNOWN + 1).SCROLL_SOURCE ## ```
                                                                 ##   SCROLL_PARAMS::reason <- keyCode
                                                                 ## ```
  SCROLL_SOURCE_SCROLLBAR* = (SCROLL_SOURCE_KEYBOARD + 1).SCROLL_SOURCE ## ```
                                                                   ##   SCROLL_PARAMS::reason <- SCROLLBAR_PART
                                                                   ## ```
  SCROLL_SOURCE_ANIMATOR* = (SCROLL_SOURCE_SCROLLBAR + 1).SCROLL_SOURCE ## ```
                                                                   ##   SCROLL_PARAMS::reason <- SCROLLBAR_PART
                                                                   ## ```
  SCROLL_SOURCE_WHEEL* = (SCROLL_SOURCE_ANIMATOR + 1).SCROLL_SOURCE
  SCROLLBAR_BASE* = (0).SCROLLBAR_PART
  SCROLLBAR_PLUS* = (SCROLLBAR_BASE + 1).SCROLLBAR_PART
  SCROLLBAR_MINUS* = (SCROLLBAR_PLUS + 1).SCROLLBAR_PART
  SCROLLBAR_SLIDER* = (SCROLLBAR_MINUS + 1).SCROLLBAR_PART
  SCROLLBAR_PAGE_MINUS* = (SCROLLBAR_SLIDER + 1).SCROLLBAR_PART
  SCROLLBAR_PAGE_PLUS* = (SCROLLBAR_PAGE_MINUS + 1).SCROLLBAR_PART
  SCROLLBAR_CORNER* = (SCROLLBAR_PAGE_PLUS + 1).SCROLLBAR_PART
  GESTURE_REQUEST* = (0).GESTURE_CMD ## ```
                                  ##   return true and fill flags if it will handle gestures.
                                  ## ```
  GESTURE_ZOOM* = (GESTURE_REQUEST + 1).GESTURE_CMD ## ```
                                               ##   The zoom gesture.
                                               ## ```
  GESTURE_PAN* = (GESTURE_ZOOM + 1).GESTURE_CMD ## ```
                                           ##   The pan gesture.
                                           ## ```
  GESTURE_ROTATE* = (GESTURE_PAN + 1).GESTURE_CMD ## ```
                                             ##   The rotation gesture.
                                             ## ```
  GESTURE_TAP1* = (GESTURE_ROTATE + 1).GESTURE_CMD ## ```
                                              ##   The tap gesture.
                                              ## ```
  GESTURE_TAP2* = (GESTURE_TAP1 + 1).GESTURE_CMD ## ```
                                            ##   The two-finger tap gesture.
                                            ## ```
  GESTURE_STATE_BEGIN* = (1).GESTURE_STATE ## ```
                                        ##   starts
                                        ## ```
  GESTURE_STATE_INERTIA* = (2).GESTURE_STATE ## ```
                                          ##   events generated by inertia processor
                                          ## ```
  GESTURE_STATE_END* = (4).GESTURE_STATE ## ```
                                      ##   end, last event of the gesture sequence
                                      ## ```
  GESTURE_FLAG_ZOOM* = (0x00000001).GESTURE_TYPE_FLAGS
  GESTURE_FLAG_ROTATE* = (0x00000002).GESTURE_TYPE_FLAGS
  GESTURE_FLAG_PAN_VERTICAL* = (0x00000004).GESTURE_TYPE_FLAGS
  GESTURE_FLAG_PAN_HORIZONTAL* = (0x00000008).GESTURE_TYPE_FLAGS
  GESTURE_FLAG_TAP1* = (0x00000010).GESTURE_TYPE_FLAGS ## ```
                                                    ##   press & tap
                                                    ## ```
  GESTURE_FLAG_TAP2* = (0x00000020).GESTURE_TYPE_FLAGS ## ```
                                                    ##   two fingers tap
                                                    ## ```
  GESTURE_FLAG_PAN_WITH_GUTTER* = (0x00004000).GESTURE_TYPE_FLAGS ## ```
                                                               ##   PAN_VERTICAL and PAN_HORIZONTAL modifiers
                                                               ## ```
  GESTURE_FLAG_PAN_WITH_INERTIA* = (0x00008000).GESTURE_TYPE_FLAGS ## ```
                                                                ##   
                                                                ## ```
  GESTURE_FLAGS_ALL* = (0x0000FFFF).GESTURE_TYPE_FLAGS ## ```
                                                    ##   
                                                    ## ```
  X_DRAG_ENTER* = (0).EXCHANGE_CMD ## ```
                                ##   drag enters the element
                                ## ```
  X_DRAG_LEAVE* = (1).EXCHANGE_CMD ## ```
                                ##   drag leaves the element
                                ## ```
  X_DRAG* = (2).EXCHANGE_CMD    ## ```
                          ##   drag over the element
                          ## ```
  X_DROP* = (3).EXCHANGE_CMD    ## ```
                          ##   data dropped on the element
                          ## ```
  X_PASTE* = (4).EXCHANGE_CMD   ## ```
                           ##   N/A
                           ## ```
  X_DRAG_REQUEST* = (5).EXCHANGE_CMD ## ```
                                  ##   N/A
                                  ## ```
  X_DRAG_CANCEL* = (6).EXCHANGE_CMD ## ```
                                 ##   drag cancelled (e.g. by pressing VK_ESCAPE)
                                 ## ```
  X_WILL_ACCEPT_DROP* = (7).EXCHANGE_CMD ## ```
                                      ##   drop target element shall consume this event in order to receive X_DROP
                                      ## ```
  DD_MODE_NONE* = (0).DD_MODES  ## ```
                            ##   DROPEFFECT_NONE	( 0 )
                            ## ```
  DD_MODE_COPY* = (1).DD_MODES  ## ```
                            ##   DROPEFFECT_COPY	( 1 )
                            ## ```
  DD_MODE_MOVE* = (2).DD_MODES  ## ```
                            ##   DROPEFFECT_MOVE	( 2 )
                            ## ```
  DD_MODE_COPY_OR_MOVE* = (3).DD_MODES ## ```
                                    ##   DROPEFFECT_COPY	( 1 ) | DROPEFFECT_MOVE	( 2 )
                                    ## ```
  DD_MODE_LINK* = (4).DD_MODES  ## ```
                            ##   DROPEFFECT_LINK	( 4 )
                            ## ```
  DRAW_BACKGROUND* = (0).DRAW_EVENTS
  DRAW_CONTENT* = (1).DRAW_EVENTS
  DRAW_FOREGROUND* = (2).DRAW_EVENTS
  DRAW_OUTLINE* = (3).DRAW_EVENTS
  CONTENT_ADDED* = (0x00000001).CONTENT_CHANGE_BITS ## ```
                                                 ##   for CONTENT_CHANGED reason
                                                 ## ```
  CONTENT_REMOVED* = (0x00000002).CONTENT_CHANGE_BITS
  BUTTON_CLICK* = (0).BEHAVIOR_EVENTS ## ```
                                   ##   click on button
                                   ## ```
  BUTTON_PRESS* = (1).BEHAVIOR_EVENTS ## ```
                                   ##   mouse down or key down in button
                                   ## ```
  BUTTON_STATE_CHANGED* = (2).BEHAVIOR_EVENTS ## ```
                                           ##   checkbox/radio/slider changed its state/value
                                           ## ```
  EDIT_VALUE_CHANGING* = (3).BEHAVIOR_EVENTS ## ```
                                          ##   before text change
                                          ## ```
  EDIT_VALUE_CHANGED* = (4).BEHAVIOR_EVENTS ## ```
                                         ##   after text change
                                         ## ```
  SELECT_SELECTION_CHANGED* = (5).BEHAVIOR_EVENTS ## ```
                                               ##   selection in <select> changed
                                               ## ```
  SELECT_STATE_CHANGED* = (6).BEHAVIOR_EVENTS ## ```
                                           ##   node in select expanded/collapsed, heTarget is the node
                                           ## ```
  POPUP_REQUEST* = (7).BEHAVIOR_EVENTS ## ```
                                    ##   request to show popup just received,
                                    ##          here DOM of popup element can be modifed.
                                    ## ```
  POPUP_READY* = (8).BEHAVIOR_EVENTS ## ```
                                  ##   popup element has been measured and ready to be shown on screen,
                                  ##          here you can use functions like ScrollToView.
                                  ## ```
  POPUP_DISMISSED* = (9).BEHAVIOR_EVENTS ## ```
                                      ##   popup element is closed,
                                      ##          here DOM of popup element can be modifed again - e.g. some items can be removed
                                      ##          to free memory.
                                      ## ```
  MENU_ITEM_ACTIVE* = (0x0000000A).BEHAVIOR_EVENTS ## ```
                                                ##   menu item activated by mouse hover or by keyboard,
                                                ## ```
  MENU_ITEM_CLICK* = (0x0000000B).BEHAVIOR_EVENTS ## ```
                                               ##   menu item click,
                                               ##        BEHAVIOR_EVENT_PARAMS structure layout
                                               ##        BEHAVIOR_EVENT_PARAMS.cmd - MENU_ITEM_CLICK/MENU_ITEM_ACTIVE
                                               ##        BEHAVIOR_EVENT_PARAMS.heTarget - owner(anchor) of the menu
                                               ##        BEHAVIOR_EVENT_PARAMS.he - the menu item, presumably <li> element
                                               ##        BEHAVIOR_EVENT_PARAMS.reason - BY_MOUSE_CLICK | BY_KEY_CLICK
                                               ## ```
  CONTEXT_MENU_REQUEST* = (0x00000010).BEHAVIOR_EVENTS ## ```
                                                    ##   "right-click", BEHAVIOR_EVENT_PARAMS::he is current popup menu HELEMENT being processed or NULL.
                                                    ##      application can provide its own HELEMENT here (if it is NULL) or modify current menu element.
                                                    ## ```
  VISIUAL_STATUS_CHANGED* = (0x00000011).BEHAVIOR_EVENTS ## ```
                                                      ##   broadcast notification, sent to all elements of some container being shown or hidden
                                                      ## ```
  DISABLED_STATUS_CHANGED* = (0x00000012).BEHAVIOR_EVENTS ## ```
                                                       ##   broadcast notification, sent to all elements of some container that got new value of :disabled state
                                                       ## ```
  POPUP_DISMISSING* = (0x00000013).BEHAVIOR_EVENTS ## ```
                                                ##   popup is about to be closed
                                                ## ```
  CONTENT_CHANGED* = (0x00000015).BEHAVIOR_EVENTS ## ```
                                               ##   content has been changed, is posted to the element that gets content changed,  reason is combination of CONTENT_CHANGE_BITS.
                                               ##      target == NULL means the window got new document and this event is dispatched only to the window.
                                               ## ```
  CLICK* = (0x00000016).BEHAVIOR_EVENTS ## ```
                                     ##   generic click
                                     ## ```
  CHANGE* = (0x00000017).BEHAVIOR_EVENTS ## ```
                                      ##   generic change
                                      ##      "grey" event codes  - notfications from behaviors from this SDK
                                      ## ```
  HYPERLINK_CLICK* = (0x00000080).BEHAVIOR_EVENTS ## ```
                                               ##   hyperlink click
                                               ##     TABLE_HEADER_CLICK,             click on some cell in table header,
                                               ##                                         target = the cell,
                                               ##                                         reason = index of the cell (column number, 0..n)
                                               ##     TABLE_ROW_CLICK,                click on data row in the table, target is the row
                                               ##                                         target = the row,
                                               ##                                         reason = index of the row (fixed_rows..n)
                                               ##     TABLE_ROW_DBL_CLICK,            mouse dbl click on data row in the table, target is the row
                                               ##                                         target = the row,
                                               ##                                         reason = index of the row (fixed_rows..n)
                                               ## ```
  ELEMENT_COLLAPSED* = (0x00000090).BEHAVIOR_EVENTS ## ```
                                                 ##   element was collapsed, so far only behavior:tabs is sending these two to the panels
                                                 ## ```
  ELEMENT_EXPANDED* = (0x00000091).BEHAVIOR_EVENTS ## ```
                                                ##   element was expanded,
                                                ## ```
  ACTIVATE_CHILD* = (0x00000092).BEHAVIOR_EVENTS ## ```
                                              ##   activate (select) child,
                                              ##      used for example by accesskeys behaviors to send activation request, e.g. tab on behavior:tabs.
                                              ##     DO_SWITCH_TAB = ACTIVATE_CHILD, command to switch tab programmatically, handled by behavior:tabs
                                              ##                                     use it as SciterPostEvent(tabsElementOrItsChild, DO_SWITCH_TAB, tabElementToShow, 0);
                                              ##     INIT_DATA_VIEW,                 request to virtual grid to initialize its view
                                              ##     ROWS_DATA_REQUEST,              request from virtual grid to data source behavior to fill data in the table
                                              ##                                     parameters passed throug DATA_ROWS_PARAMS structure.
                                              ## ```
  UI_STATE_CHANGED* = (0x00000095).BEHAVIOR_EVENTS ## ```
                                                ##   ui state changed, observers shall update their visual states.
                                                ##      is sent for example by behavior:richtext when caret position/selection has changed.
                                                ## ```
  FORM_SUBMIT* = (0x00000096).BEHAVIOR_EVENTS ## ```
                                           ##   behavior:form detected submission event. BEHAVIOR_EVENT_PARAMS::data field contains data to be posted.
                                           ##      BEHAVIOR_EVENT_PARAMS::data is of type T_MAP in this case key/value pairs of data that is about
                                           ##      to be submitted. You can modify the data or discard submission by returning true from the handler.
                                           ## ```
  FORM_RESET* = (0x00000097).BEHAVIOR_EVENTS ## ```
                                          ##   behavior:form detected reset event (from button type=reset). BEHAVIOR_EVENT_PARAMS::data field contains data to be reset.
                                          ##      BEHAVIOR_EVENT_PARAMS::data is of type T_MAP in this case key/value pairs of data that is about
                                          ##      to be rest. You can modify the data or discard reset by returning true from the handler.
                                          ## ```
  DOCUMENT_COMPLETE* = (0x00000098).BEHAVIOR_EVENTS ## ```
                                                 ##   document in behavior:frame or root document is complete.
                                                 ## ```
  HISTORY_PUSH* = (0x00000099).BEHAVIOR_EVENTS ## ```
                                            ##   requests to behavior:history (commands)
                                            ## ```
  HISTORY_DROP* = (0x0000009A).BEHAVIOR_EVENTS ## ```
                                            ##   requests to behavior:history (commands)
                                            ## ```
  HISTORY_PRIOR* = (0x0000009B).BEHAVIOR_EVENTS
  HISTORY_NEXT* = (0x0000009C).BEHAVIOR_EVENTS
  HISTORY_STATE_CHANGED* = (0x0000009D).BEHAVIOR_EVENTS ## ```
                                                     ##   behavior:history notification - history stack has changed
                                                     ## ```
  CLOSE_POPUP* = (0x0000009E).BEHAVIOR_EVENTS ## ```
                                           ##   close popup request,
                                           ## ```
  REQUEST_TOOLTIP* = (0x0000009F).BEHAVIOR_EVENTS ## ```
                                               ##   request tooltip, evt.source <- is the tooltip element.
                                               ## ```
  ANIMATION* = (0x000000A0).BEHAVIOR_EVENTS ## ```
                                         ##   animation started (reason=1) or ended(reason=0) on the element.
                                         ## ```
  DOCUMENT_CREATED* = (0x000000C0).BEHAVIOR_EVENTS ## ```
                                                ##   document created, script namespace initialized. target -> the document
                                                ## ```
  DOCUMENT_CLOSE_REQUEST* = (0x000000C1).BEHAVIOR_EVENTS ## ```
                                                      ##   document is about to be closed, to cancel closing do: evt.data = sciter::value("cancel");
                                                      ## ```
  DOCUMENT_CLOSE* = (0x000000C2).BEHAVIOR_EVENTS ## ```
                                              ##   last notification before document removal from the DOM
                                              ## ```
  DOCUMENT_READY* = (0x000000C3).BEHAVIOR_EVENTS ## ```
                                              ##   document has got DOM structure, styles and behaviors of DOM elements. Script loading run is complete at this moment.
                                              ## ```
  DOCUMENT_PARSED* = (0x000000C4).BEHAVIOR_EVENTS ## ```
                                               ##   document just finished parsing - has got DOM structure. This event is generated before DOCUMENT_READY
                                               ## ```
  VIDEO_INITIALIZED* = (0x000000D1).BEHAVIOR_EVENTS ## ```
                                                 ##   <video> "ready" notification
                                                 ## ```
  VIDEO_STARTED* = (0x000000D2).BEHAVIOR_EVENTS ## ```
                                             ##   <video> playback started notification
                                             ## ```
  VIDEO_STOPPED* = (0x000000D3).BEHAVIOR_EVENTS ## ```
                                             ##   <video> playback stoped/paused notification
                                             ## ```
  VIDEO_BIND_RQ* = (0x000000D4).BEHAVIOR_EVENTS ## ```
                                             ##   <video> request for frame source binding,
                                             ##        If you want to provide your own video frames source for the given target <video> element do the following:
                                             ##        1. Handle and consume this VIDEO_BIND_RQ request
                                             ##        2. You will receive second VIDEO_BIND_RQ request/event for the same <video> element
                                             ##           but this time with the 'reason' field set to an instance of sciter::video_destination interface.
                                             ##        3. add_ref() it and store it for example in worker thread producing video frames.
                                             ##        4. call sciter::video_destination::start_streaming(...) providing needed parameters
                                             ##           call sciter::video_destination::render_frame(...) as soon as they are available
                                             ##           call sciter::video_destination::stop_streaming() to stop the rendering (a.k.a. end of movie reached)
                                             ## ```
  PAGINATION_STARTS* = (0x000000E0).BEHAVIOR_EVENTS ## ```
                                                 ##   behavior:pager starts pagination
                                                 ## ```
  PAGINATION_PAGE* = (0x000000E1).BEHAVIOR_EVENTS ## ```
                                               ##   behavior:pager paginated page no, reason -> page no
                                               ## ```
  PAGINATION_ENDS* = (0x000000E2).BEHAVIOR_EVENTS ## ```
                                               ##   behavior:pager end pagination, reason -> total pages
                                               ## ```
  CUSTOM* = (0x000000F0).BEHAVIOR_EVENTS ## ```
                                      ##   event with custom name
                                      ## ```
  FIRST_APPLICATION_EVENT_CODE* = (0x00000100).BEHAVIOR_EVENTS ## ```
                                                            ##   all custom event codes shall be greater
                                                            ##      than this number. All codes below this will be used
                                                            ##      solely by application - Sciter will not intrepret it
                                                            ##      and will do just dispatching.
                                                            ##      To send event notifications with  these codes use
                                                            ##      SciterSend/PostEvent API.
                                                            ## ```
  BY_MOUSE_CLICK* = (0).CLICK_REASON
  BY_KEY_CLICK* = (BY_MOUSE_CLICK + 1).CLICK_REASON
  SYNTHESIZED* = (BY_KEY_CLICK + 1).CLICK_REASON ## ```
                                            ##   synthesized, programmatically generated.
                                            ## ```
  BY_MOUSE_ON_ICON* = (SYNTHESIZED + 1).CLICK_REASON ## ```
                                                ##   synthesized, programmatically generated.
                                                ## ```
  BY_INS_CHAR* = (0).EDIT_CHANGED_REASON ## ```
                                      ##   single char insertion
                                      ## ```
  BY_INS_CHARS* = (BY_INS_CHAR + 1).EDIT_CHANGED_REASON ## ```
                                                   ##   character range insertion, clipboard
                                                   ## ```
  BY_DEL_CHAR* = (BY_INS_CHARS + 1).EDIT_CHANGED_REASON ## ```
                                                   ##   single char deletion
                                                   ## ```
  BY_DEL_CHARS* = (BY_DEL_CHAR + 1).EDIT_CHANGED_REASON ## ```
                                                   ##   character range deletion (selection)
                                                   ## ```
  BY_UNDO_REDO* = (BY_DEL_CHARS + 1).EDIT_CHANGED_REASON ## ```
                                                    ##   undo/redo
                                                    ## ```
  DO_CLICK* = (0).BEHAVIOR_METHOD_IDENTIFIERS ## ```
                                           ##   remnants of HTMLayout API, not used 
                                           ##       GET_TEXT_VALUE = 1,
                                           ##       SET_TEXT_VALUE,
                                           ##          p - TEXT_VALUE_PARAMS
                                           ##   
                                           ##       TEXT_EDIT_GET_SELECTION,
                                           ##          p - TEXT_EDIT_SELECTION_PARAMS
                                           ##   
                                           ##       TEXT_EDIT_SET_SELECTION,
                                           ##          p - TEXT_EDIT_SELECTION_PARAMS
                                           ##   
                                           ##        Replace selection content or insert text at current caret position.
                                           ##        Replaced text will be selected.
                                           ##       TEXT_EDIT_REPLACE_SELECTION,
                                           ##          p - TEXT_EDIT_REPLACE_SELECTION_PARAMS
                                           ##   
                                           ##        Set value of type="vscrollbar"/"hscrollbar"
                                           ##       SCROLL_BAR_GET_VALUE,
                                           ##       SCROLL_BAR_SET_VALUE,
                                           ##   
                                           ##       TEXT_EDIT_GET_CARET_POSITION, 
                                           ##       TEXT_EDIT_GET_SELECTION_TEXT,  p - TEXT_SELECTION_PARAMS
                                           ##       TEXT_EDIT_GET_SELECTION_HTML,  p - TEXT_SELECTION_PARAMS
                                           ##       TEXT_EDIT_CHAR_POS_AT_XY,      p - TEXT_EDIT_CHAR_POS_AT_XY_PARAMS
                                           ## ```
  IS_EMPTY* = (0x000000FC).BEHAVIOR_METHOD_IDENTIFIERS ## ```
                                                    ##   p - IS_EMPTY_PARAMS  set VALUE_PARAMS::is_empty (false/true) reflects :empty state of the element.
                                                    ## ```
  GET_VALUE* = (0x000000FD).BEHAVIOR_METHOD_IDENTIFIERS ## ```
                                                     ##   p - VALUE_PARAMS
                                                     ## ```
  SET_VALUE* = (0x000000FE).BEHAVIOR_METHOD_IDENTIFIERS ## ```
                                                     ##   p - VALUE_PARAMS
                                                     ## ```
  FIRST_APPLICATION_METHOD_ID* = (0x00000100).BEHAVIOR_METHOD_IDENTIFIERS
  LOAD_OK* = (0).SC_LOAD_DATA_RETURN_CODES ## ```
                                        ##   < do default loading if data not set
                                        ## ```
  LOAD_DISCARD* = (1).SC_LOAD_DATA_RETURN_CODES ## ```
                                             ##   < discard request completely
                                             ## ```
  LOAD_DELAYED* = (2).SC_LOAD_DATA_RETURN_CODES ## ```
                                             ##   < data will be delivered later by the host application.
                                             ##                            Host application must call SciterDataReadyAsync(,,, requestId) on each LOAD_DELAYED request to avoid memory leaks.
                                             ## ```
  LOAD_MYSELF* = (3).SC_LOAD_DATA_RETURN_CODES ## ```
                                            ##   < you return LOAD_MYSELF result to indicate that your (the host) application took or will take care about HREQUEST in your code completely.
                                            ##                            Use sciter-x-request.h[pp] API functions with SCN_LOAD_DATA::requestId handle .
                                            ## ```
  SC_LOAD_DATA* = 0x00000001
  SC_DATA_LOADED* = 0x00000002
  SC_ATTACH_BEHAVIOR* = 0x00000004
  SC_ENGINE_DESTROYED* = 0x00000005
  SC_POSTED_NOTIFICATION* = 0x00000006
  SC_GRAPHICS_CRITICAL_FAILURE* = 0x00000007
  SC_KEYBOARD_REQUEST* = 0x00000008
  SC_INVALIDATE_RECT* = 0x00000009
  ALLOW_FILE_IO* = (0x00000001).SCRIPT_RUNTIME_FEATURES
  ALLOW_SOCKET_IO* = (0x00000002).SCRIPT_RUNTIME_FEATURES
  ALLOW_EVAL* = (0x00000004).SCRIPT_RUNTIME_FEATURES
  ALLOW_SYSINFO* = (0x00000008).SCRIPT_RUNTIME_FEATURES
  SCITER_SMOOTH_SCROLL* = (1).SCITER_RT_OPTIONS ## ```
                                             ##   value:TRUE - enable, value:FALSE - disable, enabled by default
                                             ## ```
  SCITER_CONNECTION_TIMEOUT* = (2).SCITER_RT_OPTIONS ## ```
                                                  ##   value: milliseconds, connection timeout of http client
                                                  ## ```
  SCITER_HTTPS_ERROR* = (3).SCITER_RT_OPTIONS ## ```
                                           ##   value: 0 - drop connection, 1 - use builtin dialog, 2 - accept connection silently
                                           ## ```
  SCITER_FONT_SMOOTHING* = (4).SCITER_RT_OPTIONS ## ```
                                              ##   value: 0 - system default, 1 - no smoothing, 2 - std smoothing, 3 - clear type
                                              ## ```
  SCITER_TRANSPARENT_WINDOW* = (6).SCITER_RT_OPTIONS ## ```
                                                  ##   Windows Aero support, value:
                                                  ##      0 - normal drawing,
                                                  ##      1 - window has transparent background after calls DwmExtendFrameIntoClientArea() or DwmEnableBlurBehindWindow().
                                                  ## ```
  SCITER_SET_GPU_BLACKLIST* = (7).SCITER_RT_OPTIONS ## ```
                                                 ##   hWnd = NULL,
                                                 ##      value = LPCBYTE, json - GPU black list, see: gpu-blacklist.json resource.
                                                 ## ```
  SCITER_SET_SCRIPT_RUNTIME_FEATURES* = (8).SCITER_RT_OPTIONS ## ```
                                                           ##   value - combination of SCRIPT_RUNTIME_FEATURES flags.
                                                           ## ```
  SCITER_SET_GFX_LAYER* = (9).SCITER_RT_OPTIONS ## ```
                                             ##   hWnd = NULL, value - GFX_LAYER
                                             ## ```
  SCITER_SET_DEBUG_MODE* = (10).SCITER_RT_OPTIONS ## ```
                                               ##   hWnd, value - TRUE/FALSE
                                               ## ```
  SCITER_SET_UX_THEMING* = (11).SCITER_RT_OPTIONS ## ```
                                               ##   hWnd = NULL, value - BOOL, TRUE - the engine will use "unisex" theme that is common for all platforms.
                                               ##      That UX theme is not using OS primitives for rendering input elements. Use it if you want exactly
                                               ##      the same (modulo fonts) look-n-feel on all platforms.
                                               ## ```
  SCITER_ALPHA_WINDOW* = (12).SCITER_RT_OPTIONS ## ```
                                             ##   hWnd, value - TRUE/FALSE - window uses per pixel alpha (e.g. WS_EX_LAYERED/UpdateLayeredWindow() window)
                                             ## ```
  SCITER_SET_INIT_SCRIPT* = (13).SCITER_RT_OPTIONS ## ```
                                                ##   hWnd - N/A , value LPCSTR - UTF-8 encoded script source to be loaded into each view before any other script execution.
                                                ##                                  The engine copies this string inside the call.
                                                ## ```
  SCITER_SET_MAIN_WINDOW* = (14).SCITER_RT_OPTIONS ## ```
                                                ##   hWnd, value - TRUE/FALSE - window is main, will destroy all other dependent windows on close
                                                ## ```
  SCITER_SET_MAX_HTTP_DATA_LENGTH* = (15).SCITER_RT_OPTIONS ## ```
                                                         ##   hWnd - N/A , value - max request length in megabytes (1024*1024 bytes)
                                                         ## ```
  SW_CHILD* = ((1 shl typeof(1)(0))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                           ##   child window only, if this flag is set all other flags ignored
                                                           ## ```
  SW_TITLEBAR* = ((1 shl typeof(1)(1))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                              ##   toplevel window, has titlebar
                                                              ## ```
  SW_RESIZEABLE* = ((1 shl typeof(1)(2))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                                ##   has resizeable frame
                                                                ## ```
  SW_TOOL* = ((1 shl typeof(1)(3))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                          ##   is tool window
                                                          ## ```
  SW_CONTROLS* = ((1 shl typeof(1)(4))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                              ##   has minimize / maximize buttons
                                                              ## ```
  SW_GLASSY* = ((1 shl typeof(1)(5))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                            ##   glassy window - supports "Acrylic" on Windows and "Vibrant" on MacOS.
                                                            ## ```
  SW_ALPHA* = ((1 shl typeof(1)(6))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                           ##   transparent window ( e.g. WS_EX_LAYERED on Windows )
                                                           ## ```
  SW_MAIN* = ((1 shl typeof(1)(7))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                          ##   main window of the app, will terminate the app on close
                                                          ## ```
  SW_POPUP* = ((1 shl typeof(1)(8))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                           ##   the window is created as topmost window.
                                                           ## ```
  SW_ENABLE_DEBUG* = ((1 shl typeof(1)(9))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                                  ##   make this window inspector ready
                                                                  ## ```
  SW_OWNS_VM* = ((1 shl typeof(1)(10))).SCITER_CREATE_WINDOW_FLAGS ## ```
                                                              ##   it has its own script VM
                                                              ## ```
  OT_DOM* = (0).OUTPUT_SUBSYTEMS ## ```
                              ##   html parser & runtime
                              ## ```
  OT_CSSS* = (OT_DOM + 1).OUTPUT_SUBSYTEMS ## ```
                                      ##   csss! parser & runtime
                                      ## ```
  OT_CSS* = (OT_CSSS + 1).OUTPUT_SUBSYTEMS ## ```
                                      ##   css parser
                                      ## ```
  OT_TIS* = (OT_CSS + 1).OUTPUT_SUBSYTEMS ## ```
                                     ##   TIS parser & runtime
                                     ## ```
  OS_INFO* = (0).OUTPUT_SEVERITY
  OS_WARNING* = (OS_INFO + 1).OUTPUT_SEVERITY
  OS_ERROR* = (OS_WARNING + 1).OUTPUT_SEVERITY
  SXM_CREATE* = (0).SCITER_X_MSG_CODE
  SXM_DESTROY* = (1).SCITER_X_MSG_CODE
  SXM_SIZE* = (2).SCITER_X_MSG_CODE
  SXM_PAINT* = (3).SCITER_X_MSG_CODE
  SXM_RESOLUTION* = (4).SCITER_X_MSG_CODE
  SXM_HEARTBIT* = (5).SCITER_X_MSG_CODE
  SXM_MOUSE* = (6).SCITER_X_MSG_CODE
  SXM_KEY* = (7).SCITER_X_MSG_CODE
  SXM_FOCUS* = (8).SCITER_X_MSG_CODE
  SPT_DEFAULT* = (0).SCITER_PAINT_TARGET_TYPE ## ```
                                           ##   < default rendering target - window surface
                                           ## ```
  SPT_RECEIVER* = (1).SCITER_PAINT_TARGET_TYPE ## ```
                                            ##   < target::receiver fields are valid
                                            ## ```
  SPT_SURFACE* = (2).SCITER_PAINT_TARGET_TYPE ## ```
                                           ##   < target::pSurface is valid 
                                           ##     SPT_OPENGL    = 3,  < target is not used - caller shall set current context on its side  
                                           ##     SPT_OPENGLES  = 4,  < target is not used - caller shall set current context on its side  
                                           ##     SPT_
                                           ## ```
  SCITER_API_VERSION* = 6
type
  HELEMENT* = distinct pointer
  LPRECT* = ptr RECT
  HWINDOW* = GtkWidget
  GtkWidget* {.header: "gtk/gtk.h", importc.} = object
  RECT* {.bycopy.} = object
    left*: INT
    top*: INT
    right*: INT
    bottom*: INT

  SCITER_VALUE* = VALUE
  SCDOM_RESULT* {.size: 4.} = enum
    SCDOM_OK_NOT_HANDLED = (-1), SCDOM_OK = 0, SCDOM_INVALID_HWND = 1,
    SCDOM_INVALID_HANDLE = 2, SCDOM_PASSIVE_HANDLE = 3, SCDOM_INVALID_PARAMETER = 4,
    SCDOM_OPERATION_FAILED = 5
  INT* = cint
  UINT32* = cuint
  INT32* = cint
  UINT64* = culonglong
  INT64* = clonglong
  BYTE* = cuchar
  WCHAR* = cushort
  LPCWSTR* = ptr WCHAR
  LPWSTR* = ptr WCHAR
  CHAR* = cchar
  LPCSTR* = ptr CHAR
  VOID* = object
  UINT_PTR* = uint
  LPVOID* = pointer
  LPCVOID* = pointer
  LPCRECT* = ptr RECT
  tagPOINT* {.bycopy.} = object
    x*: INT
    y*: INT

  POINT* = tagPOINT
  PPOINT* = ptr tagPOINT
  LPPOINT* = ptr tagPOINT
  tagSIZE* {.bycopy.} = object
    cx*: INT
    cy*: INT

  SIZE* = tagSIZE
  PSIZE* = ptr tagSIZE
  LPSIZE* = ptr tagSIZE
  LPUINT* = ptr cuint
  LPCBYTE* = ptr BYTE
  LPCWSTR_RECEIVER* = proc (str: LPCWSTR; str_length: cuint; param: LPVOID): VOID {.cdecl.}
  LPCSTR_RECEIVER* = proc (str: LPCSTR; str_length: cuint; param: LPVOID): VOID {.cdecl.}
  LPCBYTE_RECEIVER* = proc (str: LPCBYTE; num_bytes: cuint; param: LPVOID): VOID {.cdecl.}
  HREQUEST* = pointer ## ```
                   ##   The Sciter Engine of Terra Informatica Software, Inc.
                   ##    http:sciter.com
                   ##   
                   ##    The code and information provided "as-is" without
                   ##    warranty of any kind, either expressed or implied.
                   ##   
                   ##    (C) 2003-2015, Terra Informatica Software, Inc.
                   ##    
                   ##     
                   ##    Sciter basic types, platform isolation declarations
                   ## ```
  SciterRequestAPI* {.bycopy.} = object
    RequestUse*: proc (rq: HREQUEST): REQUEST_RESULT {.cdecl.} ## ```
                                                         ##   a.k.a AddRef()
                                                         ## ```
    RequestUnUse*: proc (rq: HREQUEST): REQUEST_RESULT {.cdecl.} ## ```
                                                           ##   a.k.a Release()
                                                           ## ```
    RequestUrl*: proc (rq: HREQUEST; rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get requested URL
               ## ```
    RequestContentUrl*: proc (rq: HREQUEST; rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.} ## ```
               ##   get real, content URL (after possible redirection)
               ## ```
    RequestGetRequestType*: proc (rq: HREQUEST; pType: ptr REQUEST_RQ_TYPE): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get requested data type
               ## ```
    RequestGetRequestedDataType*: proc (rq: HREQUEST; pData: ptr SciterResourceType): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get requested data type
               ## ```
    RequestGetReceivedDataType*: proc (rq: HREQUEST; rcv: LPCSTR_RECEIVER;
                                     rcv_param: LPVOID): REQUEST_RESULT {.cdecl.} ## ```
                                                                              ##   get received data type, string, mime type
                                                                              ## ```
    RequestGetNumberOfParameters*: proc (rq: HREQUEST; pNumber: ptr cuint): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get number of request parameters passed
               ## ```
    RequestGetNthParameterName*: proc (rq: HREQUEST; n: cuint;
                                     rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth request parameter name
               ## ```
    RequestGetNthParameterValue*: proc (rq: HREQUEST; n: cuint;
                                      rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth request parameter value
               ## ```
    RequestGetTimes*: proc (rq: HREQUEST; pStarted: ptr cuint; pEnded: ptr cuint): REQUEST_RESULT {.
        cdecl.} ## ```
               ##   get request times , ended - started = milliseconds to get the requst
               ## ```
    RequestGetNumberOfRqHeaders*: proc (rq: HREQUEST; pNumber: ptr cuint): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get number of request headers
               ## ```
    RequestGetNthRqHeaderName*: proc (rq: HREQUEST; n: cuint;
                                    rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth request header name
               ## ```
    RequestGetNthRqHeaderValue*: proc (rq: HREQUEST; n: cuint;
                                     rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth request header value
               ## ```
    RequestGetNumberOfRspHeaders*: proc (rq: HREQUEST; pNumber: ptr cuint): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get number of response headers
               ## ```
    RequestGetNthRspHeaderName*: proc (rq: HREQUEST; n: cuint;
                                     rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth response header name
               ## ```
    RequestGetNthRspHeaderValue*: proc (rq: HREQUEST; n: cuint;
                                      rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get nth response header value
               ## ```
    RequestGetCompletionStatus*: proc (rq: HREQUEST; pState: ptr REQUEST_STATE;
                                     pCompletionStatus: ptr cuint): REQUEST_RESULT {.
        cdecl.} ## ```
               ##   get completion status (CompletionStatus - http response code : 200, 404, etc.)
               ## ```
    RequestGetProxyHost*: proc (rq: HREQUEST; rcv: LPCSTR_RECEIVER;
                              rcv_param: LPVOID): REQUEST_RESULT {.cdecl.} ## ```
                                                                       ##   get proxy host
                                                                       ## ```
    RequestGetProxyPort*: proc (rq: HREQUEST; pPort: ptr cuint): REQUEST_RESULT {.cdecl.} ## ```
                                                                                 ##   get proxy port
                                                                                 ## ```
    RequestSetSucceeded*: proc (rq: HREQUEST; status: cuint; dataOrNull: LPCBYTE;
                              dataLength: cuint): REQUEST_RESULT {.cdecl.} ## ```
                                                                       ##   mark reequest as complete with status and data
                                                                       ## ```
    RequestSetFailed*: proc (rq: HREQUEST; status: cuint; dataOrNull: LPCBYTE;
                           dataLength: cuint): REQUEST_RESULT {.cdecl.} ## ```
                                                                    ##   mark reequest as complete with failure and optional data
                                                                    ## ```
    RequestAppendDataChunk*: proc (rq: HREQUEST; data: LPCBYTE; dataLength: cuint): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   append received data chunk
               ## ```
    RequestSetRqHeader*: proc (rq: HREQUEST; name: LPCWSTR; value: LPCWSTR): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   set request header (single item)
               ## ```
    RequestSetRspHeader*: proc (rq: HREQUEST; name: LPCWSTR; value: LPCWSTR): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   set respone header (single item)
               ## ```
    RequestSetReceivedDataType*: proc (rq: HREQUEST; `type`: LPCSTR): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   set received data type, string, mime type
               ## ```
    RequestSetReceivedDataEncoding*: proc (rq: HREQUEST; encoding: LPCSTR): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   set received data encoding, string
               ## ```
    RequestGetData*: proc (rq: HREQUEST; rcv: LPCBYTE_RECEIVER; rcv_param: LPVOID): REQUEST_RESULT {.
        cdecl.}               ## ```
               ##   get received (so far) data
               ## ```
  
  LPSciterRequestAPI* = ptr SciterRequestAPI
  VALUE* {.bycopy.} = object
    t*: cuint
    u*: cuint
    d*: UINT64

  NATIVE_FUNCTOR_INVOKE* = proc (tag: ptr VOID; argc: cuint; argv: ptr VALUE;
                              retval: ptr VALUE): VOID {.cdecl.}
  NATIVE_FUNCTOR_RELEASE* = proc (tag: ptr VOID): VOID {.cdecl.}
  KeyValueCallback* = proc (param: LPVOID; pkey: ptr VALUE; pval: ptr VALUE): bool {.cdecl.}
  HNODE* = pointer              ## ```
                ##   DOM node handle.
                ## ```
  HRANGE* = pointer             ## ```
                 ##   DOM range handle.
                 ## ```
  HSARCHIVE* = pointer
  hposition* {.bycopy.} = object
    hn*: HNODE
    pos*: INT

  HPOSITION* = hposition
  BEHAVIOR_EVENT_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   BEHAVIOR_EVENTS
              ## ```
    heTarget*: HELEMENT ## ```
                      ##   target element handler, in MENU_ITEM_CLICK this is owner element that caused this menu - e.g. context menu owner
                      ##      In scripting this field named as Event.owner
                      ## ```
    he*: HELEMENT ## ```
                ##   source element e.g. in SELECTION_CHANGED it is new selected <option>, in MENU_ITEM_CLICK it is menu item (LI) element
                ## ```
    reason*: UINT_PTR ## ```
                    ##   CLICK_REASON or EDIT_CHANGED_REASON - UI action causing change.
                    ##      In case of custom event notifications this may be any
                    ##      application specific value.
                    ## ```
    data*: SCITER_VALUE ## ```
                      ##   auxiliary data accompanied with the event. E.g. FORM_SUBMIT event is using this field to pass collection of values.
                      ## ```
    name*: LPCWSTR             ## ```
                 ##   name of custom event (when cmd == CUSTOM)
                 ## ```
  
  METHOD_PARAMS* {.bycopy.} = object
    methodID*: cuint

  REQUEST_PARAM* {.bycopy.} = object
    name*: LPCWSTR
    value*: LPCWSTR

  SciterElementCallback* = proc (he: HELEMENT; param: LPVOID): bool {.cdecl.}
  ElementEventProc* = proc (tag: LPVOID; he: HELEMENT; evtg: cuint; prms: LPVOID): bool {.
      cdecl.}
  C_LPELEMENT_EVENT_PROC* = ElementEventProc
  ELEMENT_COMPARATOR* = proc (he1: HELEMENT; he2: HELEMENT; param: LPVOID): INT {.cdecl.}
  HGFX* = pointer ## ```
               ##   The Sciter Engine of Terra Informatica Software, Inc.
               ##    http:sciter.com
               ##   
               ##    The code and information provided "as-is" without
               ##    warranty of any kind, either expressed or implied.
               ##   
               ##    (C) 2003-2015, Terra Informatica Software, Inc.
               ##    
               ##     
               ##    Sciter basic types, platform isolation declarations
               ## ```
  HIMG* = pointer
  HPATH* = pointer
  HTEXT* = pointer
  SC_REAL* = cfloat
  SC_POS* = SC_REAL             ## ```
                 ##   position
                 ## ```
  SC_DIM* = SC_REAL             ## ```
                 ##   dimension
                 ## ```
  SC_ANGLE* = SC_REAL           ## ```
                   ##   angle (radians)
                   ## ```
  SC_COLOR* = cuint             ## ```
                 ##   color
                 ## ```
  SC_COLOR_STOP* {.bycopy.} = object
    color*: SC_COLOR
    offset*: cfloat            ## ```
                  ##   0.0 ... 1.0
                  ## ```
  
  image_write_function* = proc (prm: LPVOID; data: ptr BYTE; data_length: cuint): bool {.
      cdecl.}
  image_paint_function* = proc (prm: LPVOID; hgfx: HGFX; width: cuint; height: cuint): VOID {.
      cdecl.}
  SciterGraphicsAPI* {.bycopy.} = object
    imageCreate*: proc (poutImg: ptr HIMG; width: cuint; height: cuint; withAlpha: bool): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   image primitives
               ## ```
    imageCreateFromPixmap*: proc (poutImg: ptr HIMG; pixmapWidth: cuint;
                                pixmapHeight: cuint; withAlpha: bool;
                                pixmap: ptr BYTE): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                       ##   construct image from B[n+0],G[n+1],R[n+2],A[n+3] data.
                                                                       ##      Size of pixmap data is pixmapWidth*pixmapHeight*4
                                                                       ## ```
    imageAddRef*: proc (himg: HIMG): GRAPHIN_RESULT {.cdecl.}
    imageRelease*: proc (himg: HIMG): GRAPHIN_RESULT {.cdecl.}
    imageGetInfo*: proc (himg: HIMG; width: ptr cuint; height: ptr cuint;
                       usesAlpha: ptr bool): GRAPHIN_RESULT {.cdecl.}
    imageClear*: proc (himg: HIMG; byColor: SC_COLOR): GRAPHIN_RESULT {.cdecl.}
    imageLoad*: proc (bytes: ptr BYTE; num_bytes: cuint; pout_img: ptr HIMG): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   load png/jpeg/etc. image from stream of bytes
               ## ```
    imageSave*: proc (himg: HIMG; pfn: ptr image_write_function; prm: pointer;
                    encoding: cuint; quality: cuint): GRAPHIN_RESULT {.cdecl.}
    RGBA*: proc (red: cuint; green: cuint; blue: cuint; alpha: cuint): SC_COLOR {.cdecl.} ## ```
                                                                              ##   SECTION: graphics primitives and drawing operations
                                                                              ##      create SC_COLOR value
                                                                              ## ```
    gCreate*: proc (img: HIMG; pout_gfx: ptr HGFX): GRAPHIN_RESULT {.cdecl.}
    gAddRef*: proc (gfx: HGFX): GRAPHIN_RESULT {.cdecl.}
    gRelease*: proc (gfx: HGFX): GRAPHIN_RESULT {.cdecl.}
    gLine*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS; y2: SC_POS): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   Draws line from x1,y1 to x2,y2 using current lineColor and lineGradient.
               ## ```
    gRectangle*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS; y2: SC_POS): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   Draws rectangle using current lineColor/lineGradient and fillColor/fillGradient with (optional) rounded corners.
               ## ```
    gRoundedRectangle*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS; y2: SC_POS;
                            radii8: ptr SC_DIM): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                     ##   Draws rounded rectangle using current lineColor/lineGradient and fillColor/fillGradient with (optional) rounded corners.
                                                                     ## ```
    gEllipse*: proc (hgfx: HGFX; x: SC_POS; y: SC_POS; rx: SC_DIM; ry: SC_DIM): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   Draws circle or ellipse using current lineColor/lineGradient and fillColor/fillGradient.
               ## ```
    gArc*: proc (hgfx: HGFX; x: SC_POS; y: SC_POS; rx: SC_POS; ry: SC_POS; start: SC_ANGLE;
               sweep: SC_ANGLE): GRAPHIN_RESULT {.cdecl.} ## ```
                                                      ##   Draws closed arc using current lineColor/lineGradient and fillColor/fillGradient.
                                                      ## ```
    gStar*: proc (hgfx: HGFX; x: SC_POS; y: SC_POS; r1: SC_DIM; r2: SC_DIM; start: SC_ANGLE;
                rays: cuint): GRAPHIN_RESULT {.cdecl.} ## ```
                                                   ##   Draws star.
                                                   ## ```
    gPolygon*: proc (hgfx: HGFX; xy: ptr SC_POS; num_points: cuint): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   Closed polygon.
               ## ```
    gPolyline*: proc (hgfx: HGFX; xy: ptr SC_POS; num_points: cuint): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   Polyline.
               ## ```
    pathCreate*: proc (path: ptr HPATH): GRAPHIN_RESULT {.cdecl.}
    pathAddRef*: proc (path: HPATH): GRAPHIN_RESULT {.cdecl.}
    pathRelease*: proc (path: HPATH): GRAPHIN_RESULT {.cdecl.}
    pathMoveTo*: proc (path: HPATH; x: SC_POS; y: SC_POS; relative: bool): GRAPHIN_RESULT {.
        cdecl.}
    pathLineTo*: proc (path: HPATH; x: SC_POS; y: SC_POS; relative: bool): GRAPHIN_RESULT {.
        cdecl.}
    pathArcTo*: proc (path: HPATH; x: SC_POS; y: SC_POS; angle: SC_ANGLE; rx: SC_DIM;
                    ry: SC_DIM; is_large_arc: bool; clockwise: bool; relative: bool): GRAPHIN_RESULT {.
        cdecl.}
    pathQuadraticCurveTo*: proc (path: HPATH; xc: SC_POS; yc: SC_POS; x: SC_POS;
                               y: SC_POS; relative: bool): GRAPHIN_RESULT {.cdecl.}
    pathBezierCurveTo*: proc (path: HPATH; xc1: SC_POS; yc1: SC_POS; xc2: SC_POS;
                            yc2: SC_POS; x: SC_POS; y: SC_POS; relative: bool): GRAPHIN_RESULT {.
        cdecl.}
    pathClosePath*: proc (path: HPATH): GRAPHIN_RESULT {.cdecl.}
    gDrawPath*: proc (hgfx: HGFX; path: HPATH; dpm: DRAW_PATH_MODE): GRAPHIN_RESULT {.
        cdecl.}
    gRotate*: proc (hgfx: HGFX; radians: SC_ANGLE; cx: ptr SC_POS; cy: ptr SC_POS): GRAPHIN_RESULT {.
        cdecl.}
    gTranslate*: proc (hgfx: HGFX; cx: SC_POS; cy: SC_POS): GRAPHIN_RESULT {.cdecl.}
    gScale*: proc (hgfx: HGFX; x: SC_DIM; y: SC_DIM): GRAPHIN_RESULT {.cdecl.}
    gSkew*: proc (hgfx: HGFX; dx: SC_DIM; dy: SC_DIM): GRAPHIN_RESULT {.cdecl.}
    gTransform*: proc (hgfx: HGFX; m11: SC_POS; m12: SC_POS; m21: SC_POS; m22: SC_POS;
                     dx: SC_POS; dy: SC_POS): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                 ##   all above in one shot
                                                                 ## ```
    gStateSave*: proc (hgfx: HGFX): GRAPHIN_RESULT {.cdecl.}
    gStateRestore*: proc (hgfx: HGFX): GRAPHIN_RESULT {.cdecl.}
    gLineWidth*: proc (hgfx: HGFX; width: SC_DIM): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                    ##   end of state save/restore
                                                                    ##      SECTION: drawing attributes
                                                                    ##      set line width for subsequent drawings.
                                                                    ## ```
    gLineJoin*: proc (hgfx: HGFX; `type`: SCITER_LINE_JOIN_TYPE): GRAPHIN_RESULT {.
        cdecl.}
    gLineCap*: proc (hgfx: HGFX; `type`: SCITER_LINE_CAP_TYPE): GRAPHIN_RESULT {.cdecl.}
    gLineColor*: proc (hgfx: HGFX; c: SC_COLOR): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                  ##   GRAPHIN_RESULT SCFN
                                                                  ##           (*gNoLine ( HGFX hgfx ) { gLineWidth(hgfx,0.0); }
                                                                  ##      SC_COLOR for solid lines/strokes
                                                                  ## ```
    gFillColor*: proc (hgfx: HGFX; color: SC_COLOR): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                      ##   SC_COLOR for solid fills
                                                                      ## ```
    gLineGradientLinear*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS;
                              y2: SC_POS; stops: ptr SC_COLOR_STOP; nstops: cuint): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   inline void
               ##           graphics_no_fill ( HGFX hgfx ) { graphics_fill_color(hgfx, graphics_rgbt(0,0,0,0xFF)); }
               ##      setup parameters of linear gradient of lines.
               ## ```
    gFillGradientLinear*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS;
                              y2: SC_POS; stops: ptr SC_COLOR_STOP; nstops: cuint): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   setup parameters of linear gradient of fills.
               ## ```
    gLineGradientRadial*: proc (hgfx: HGFX; x: SC_POS; y: SC_POS; rx: SC_DIM; ry: SC_DIM;
                              stops: ptr SC_COLOR_STOP; nstops: cuint): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   setup parameters of line gradient radial fills.
               ## ```
    gFillGradientRadial*: proc (hgfx: HGFX; x: SC_POS; y: SC_POS; rx: SC_DIM; ry: SC_DIM;
                              stops: ptr SC_COLOR_STOP; nstops: cuint): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   setup parameters of gradient radial fills.
               ## ```
    gFillMode*: proc (hgfx: HGFX; even_odd: bool): GRAPHIN_RESULT {.cdecl.}
    textCreateForElement*: proc (ptext: ptr HTEXT; text: LPCWSTR; textLength: cuint;
                               he: HELEMENT; classNameOrNull: LPCWSTR): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   SECTION: text
               ##      create text layout for host element
               ## ```
    textCreateForElementAndStyle*: proc (ptext: ptr HTEXT; text: LPCWSTR;
                                       textLength: cuint; he: HELEMENT;
                                       style: LPCWSTR; styleLength: cuint): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   create text layout using explicit style declaration
               ## ```
    textAddRef*: proc (path: HTEXT): GRAPHIN_RESULT {.cdecl.}
    textRelease*: proc (path: HTEXT): GRAPHIN_RESULT {.cdecl.}
    textGetMetrics*: proc (text: HTEXT; minWidth: ptr SC_DIM; maxWidth: ptr SC_DIM;
                         height: ptr SC_DIM; ascent: ptr SC_DIM; descent: ptr SC_DIM;
                         nLines: ptr cuint): GRAPHIN_RESULT {.cdecl.}
    textSetBox*: proc (text: HTEXT; width: SC_DIM; height: SC_DIM): GRAPHIN_RESULT {.
        cdecl.}
    gDrawText*: proc (hgfx: HGFX; text: HTEXT; px: SC_POS; py: SC_POS; position: cuint): GRAPHIN_RESULT {.
        cdecl.} ## ```
               ##   draw text with position (1..9 on MUMPAD) at px,py
               ##      Ex: gDrawText( 100,100,5) will draw text box with its center at 100,100 px
               ## ```
    gDrawImage*: proc (hgfx: HGFX; himg: HIMG; x: SC_POS; y: SC_POS; w: ptr SC_DIM;
                     h: ptr SC_DIM; ix: ptr cuint; iy: ptr cuint; iw: ptr cuint;
                     ih: ptr cuint; opacity: ptr cfloat): GRAPHIN_RESULT {.cdecl.} ## ```
                                                                           ##   SECTION: image rendering
                                                                           ##      draws img onto the graphics surface with current transformation applied (scale, rotation).
                                                                           ## ```
    gWorldToScreen*: proc (hgfx: HGFX; inout_x: ptr SC_POS; inout_y: ptr SC_POS): GRAPHIN_RESULT {.
        cdecl.}
    gScreenToWorld*: proc (hgfx: HGFX; inout_x: ptr SC_POS; inout_y: ptr SC_POS): GRAPHIN_RESULT {.
        cdecl.}
    gPushClipBox*: proc (hgfx: HGFX; x1: SC_POS; y1: SC_POS; x2: SC_POS; y2: SC_POS;
                       opacity: cfloat): GRAPHIN_RESULT {.cdecl.}
    gPushClipPath*: proc (hgfx: HGFX; hpath: HPATH; opacity: cfloat): GRAPHIN_RESULT {.
        cdecl.}
    gPopClip*: proc (hgfx: HGFX): GRAPHIN_RESULT {.cdecl.} ## ```
                                                     ##   pop clip layer previously set by gPushClipBox or gPushClipPath
                                                     ## ```
    imagePaint*: proc (himg: HIMG; pPainter: ptr image_paint_function; prm: pointer): GRAPHIN_RESULT {.
        cdecl.}               ## ```
               ##   paint on image using graphics
               ##      VALUE interface
               ## ```
    vWrapGfx*: proc (hgfx: HGFX; toValue: ptr VALUE): GRAPHIN_RESULT {.cdecl.}
    vWrapImage*: proc (himg: HIMG; toValue: ptr VALUE): GRAPHIN_RESULT {.cdecl.}
    vWrapPath*: proc (hpath: HPATH; toValue: ptr VALUE): GRAPHIN_RESULT {.cdecl.}
    vWrapText*: proc (htext: HTEXT; toValue: ptr VALUE): GRAPHIN_RESULT {.cdecl.}
    vUnWrapGfx*: proc (fromValue: ptr VALUE; phgfx: ptr HGFX): GRAPHIN_RESULT {.cdecl.}
    vUnWrapImage*: proc (fromValue: ptr VALUE; phimg: ptr HIMG): GRAPHIN_RESULT {.cdecl.}
    vUnWrapPath*: proc (fromValue: ptr VALUE; phpath: ptr HPATH): GRAPHIN_RESULT {.cdecl.}
    vUnWrapText*: proc (fromValue: ptr VALUE; phtext: ptr HTEXT): GRAPHIN_RESULT {.cdecl.}
    gFlush*: proc (hgfx: HGFX): GRAPHIN_RESULT {.cdecl.}

  LPSciterGraphicsAPI* = ptr SciterGraphicsAPI
  som_passport_t* {.bycopy.} = object ## ```
                                  ##   definiton of object (the thing) access interface
                                  ##      this structure should be statically allocated - at least survive last instance of the engine
                                  ## ```
    flags*: UINT64
    name*: som_atom_t          ## ```
                    ##   class name
                    ## ```
    properties*: ptr som_property_def_t ## ```
                                     ##   class name
                                     ## ```
    n_properties*: uint        ## ```
                      ##   virtual property thunks
                      ## ```
    methods*: ptr som_method_def_t ## ```
                                ##   virtual property thunks
                                ## ```
    n_methods*: uint           ## ```
                   ##   method thunks
                   ## ```
    item_getter*: som_item_getter_t ## ```
                                  ##   var item_val = thing[k];
                                  ## ```
    item_setter*: som_item_setter_t ## ```
                                  ##   thing[k] = item_val;
                                  ## ```
    item_next*: som_item_next_t ## ```
                              ##   for(var item in thisThing)
                              ##      any property "inteceptors"
                              ## ```
    prop_getter*: som_any_prop_getter_t ## ```
                                      ##   var prop_val = thing.k;
                                      ## ```
    prop_setter*: som_any_prop_setter_t ## ```
                                      ##   thing.k = prop_val;
                                      ## ```
  
  som_atom_t* = UINT64
  som_asset_t* {.bycopy.} = object
    isa*: ptr som_asset_class_t

  som_asset_class_t* {.bycopy.} = object
    asset_add_ref*: proc (thing: ptr som_asset_t): clong {.cdecl.}
    asset_release*: proc (thing: ptr som_asset_t): clong {.cdecl.}
    asset_get_interface*: proc (thing: ptr som_asset_t; name: cstring;
                              `out`: ptr pointer): clong {.cdecl.}
    asset_get_passport*: proc (thing: ptr som_asset_t): ptr som_passport_t {.cdecl.}

  som_prop_getter_t* = proc (thing: ptr som_asset_t; p_value: ptr SCITER_VALUE): bool {.
      cdecl.}
  som_prop_setter_t* = proc (thing: ptr som_asset_t; p_value: ptr SCITER_VALUE): bool {.
      cdecl.}
  som_item_getter_t* = proc (thing: ptr som_asset_t; p_key: ptr SCITER_VALUE;
                          p_value: ptr SCITER_VALUE): bool {.cdecl.}
  som_item_setter_t* = proc (thing: ptr som_asset_t; p_key: ptr SCITER_VALUE;
                          p_value: ptr SCITER_VALUE): bool {.cdecl.}
  som_item_next_t* = proc (thing: ptr som_asset_t; p_idx: ptr SCITER_VALUE;
                        p_value: ptr SCITER_VALUE): bool {.cdecl.}
  som_any_prop_getter_t* = proc (thing: ptr som_asset_t; propSymbol: UINT64;
                              p_value: ptr SCITER_VALUE): bool {.cdecl.}
  som_any_prop_setter_t* = proc (thing: ptr som_asset_t; propSymbol: UINT64;
                              p_value: ptr SCITER_VALUE): bool {.cdecl.}
  som_method_t* = proc (thing: ptr som_asset_t; argc: cuint; argv: ptr SCITER_VALUE;
                     p_result: ptr SCITER_VALUE): bool {.cdecl.}
  som_dispose_t* = proc (thing: ptr som_asset_t) {.cdecl.}
  som_property_def_t* {.bycopy.} = object
    reserved*: pointer
    name*: som_atom_t
    getter*: som_prop_getter_t
    setter*: som_prop_setter_t

  som_method_def_t* {.bycopy.} = object
    reserved*: pointer
    name*: som_atom_t
    params*: uint
    `func`*: som_method_t

  LPElementEventProc* = ElementEventProc ## ```
                                         ##   signature of the function exported from external behavior/dll.
                                         ## ```
  SciterBehaviorFactory* = proc (a1: LPCSTR; a2: HELEMENT; a3: ptr LPElementEventProc;
                              a4: ptr LPVOID): bool {.cdecl.}
  INITIALIZATION_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   INITIALIZATION_EVENTS
              ## ```
  
  Union_sciterxh1* {.union, bycopy.} = object ## ```
                                         ##   SOM_EVENTS
                                         ## ```
    passport*: ptr som_passport_t
    asset*: ptr som_asset_t

  SOM_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   SOM_EVENTS
              ## ```
    data*: Union_sciterxh1     ## ```
                         ##   SOM_EVENTS
                         ## ```
  
  MOUSE_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   MOUSE_EVENTS
              ## ```
    target*: HELEMENT          ## ```
                    ##   target element
                    ## ```
    pos*: POINT                ## ```
              ##   position of cursor, element relative
              ## ```
    pos_view*: POINT           ## ```
                   ##   position of cursor, view relative
                   ## ```
    button_state*: cuint       ## ```
                       ##   MOUSE_BUTTONS
                       ## ```
    alt_state*: cuint          ## ```
                    ##   KEYBOARD_STATES
                    ## ```
    cursor_type*: cuint        ## ```
                      ##   CURSOR_TYPE to set, see CURSOR_TYPE
                      ## ```
    is_on_icon*: bool ## ```
                    ##   mouse is over icon (foreground-image, foreground-repeat:no-repeat)
                    ## ```
    dragging*: HELEMENT ## ```
                      ##   element that is being dragged over, this field is not NULL if (cmd & DRAGGING) != 0
                      ## ```
    dragging_mode*: cuint      ## ```
                        ##   see DRAGGING_TYPE.
                        ## ```
  
  KEY_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   KEY_EVENTS
              ## ```
    target*: HELEMENT          ## ```
                    ##   target element
                    ## ```
    key_code*: cuint           ## ```
                   ##   key scan code, or character unicode for KEY_CHAR
                   ## ```
    alt_state*: cuint          ## ```
                    ##   KEYBOARD_STATES
                    ## ```
  
  FOCUS_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   < #FOCUS_EVENTS
              ## ```
    target*: HELEMENT ## ```
                    ##   < target element, for #FOCUS_LOST it is a handle of new focus element
                    ##                                        and for #FOCUS_GOT it is a handle of old focus element, can be NULL
                    ## ```
    cause*: cuint ## ```
                ##   < focus cause params or FOCUS_CMD_TYPE for FOCUS_ADVANCE_REQUEST
                ## ```
    cancel*: bool ## ```
                ##   < in #FOCUS_REQUEST and #FOCUS_LOST phase setting this field to true will cancel transfer focus from old element to the new one.
                ## ```
  
  SCROLL_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   SCROLL_EVENTS
              ## ```
    target*: HELEMENT          ## ```
                    ##   target element
                    ## ```
    pos*: INT                  ## ```
            ##   scroll position if SCROLL_POS
            ## ```
    vertical*: bool            ## ```
                  ##   true if from vertical scrollbar
                  ## ```
    source*: cuint             ## ```
                 ##   SCROLL_SOURCE
                 ## ```
    reason*: cuint             ## ```
                 ##   key or scrollbar part
                 ## ```
  
  GESTURE_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   GESTURE_EVENTS
              ## ```
    target*: HELEMENT          ## ```
                    ##   target element
                    ## ```
    pos*: POINT                ## ```
              ##   position of cursor, element relative
              ## ```
    pos_view*: POINT           ## ```
                   ##   position of cursor, view relative
                   ## ```
    flags*: cuint ## ```
                ##   for GESTURE_REQUEST combination of GESTURE_FLAGs.
                ##      for others it is a combination of GESTURE_STATe's
                ## ```
    delta_time*: cuint         ## ```
                     ##   period of time from previous event.
                     ## ```
    delta_xy*: SIZE            ## ```
                  ##   for GESTURE_PAN it is a direction vector
                  ## ```
    delta_v*: cdouble ## ```
                    ##   for GESTURE_ROTATE - delta angle (radians)
                    ##      for GESTURE_ZOOM - zoom value, is less or greater than 1.0
                    ## ```
  
  EXCHANGE_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   EXCHANGE_EVENTS
              ## ```
    target*: HELEMENT          ## ```
                    ##   target element
                    ## ```
    source*: HELEMENT ## ```
                    ##   source element (can be null if D&D from external window)
                    ## ```
    pos*: POINT                ## ```
              ##   position of cursor, element relative
              ## ```
    pos_view*: POINT           ## ```
                   ##   position of cursor, view relative
                   ## ```
    mode*: cuint               ## ```
               ##   DD_MODE
               ## ```
    data*: SCITER_VALUE        ## ```
                      ##   packaged drag data
                      ## ```
  
  SCITER_GRAPHICS* {.incompleteStruct.} = object
  DRAW_PARAMS* {.bycopy.} = object
    cmd*: cuint                ## ```
              ##   DRAW_EVENTS
              ## ```
    gfx*: HGFX                 ## ```
             ##   hdc to paint on
             ## ```
    area*: RECT ## ```
              ##   element area, to get invalid area to paint use GetClipBox,
              ## ```
    reserved*: cuint ## ```
                   ##   for DRAW_BACKGROUND/DRAW_FOREGROUND - it is a border box
                   ##      for DRAW_CONTENT - it is a content box
                   ## ```
  
  TIMER_PARAMS* {.bycopy.} = object
    timerId*: UINT_PTR ## ```
                     ##   timerId that was used to create timer by using SciterSetTimer
                     ## ```
  
  SCRIPTING_METHOD_PARAMS* {.bycopy.} = object
    name*: LPCSTR              ## ```
                ##   /< method name
                ## ```
    argv*: ptr SCITER_VALUE     ## ```
                         ##   /< vector of arguments
                         ## ```
    argc*: cuint               ## ```
               ##   /< argument count
               ## ```
    result*: SCITER_VALUE      ## ```
                        ##   /< return value
                        ## ```
  
  VALUE_PARAMS* {.bycopy.} = object
    methodID*: cuint
    val*: SCITER_VALUE

  IS_EMPTY_PARAMS* {.bycopy.} = object
    methodID*: cuint
    is_empty*: cuint           ## ```
                   ##   !0 - is empty
                   ## ```
  
  DATA_ARRIVED_PARAMS* {.bycopy.} = object
    initiator*: HELEMENT ## ```
                       ##   element intiator of SciterRequestElementData request,
                       ## ```
    data*: LPCBYTE             ## ```
                 ##   data buffer
                 ## ```
    dataSize*: cuint           ## ```
                   ##   size of data
                   ## ```
    dataType*: cuint ## ```
                   ##   data type passed "as is" from SciterRequestElementData
                   ## ```
    status*: cuint ## ```
                 ##   status = 0 (dataSize == 0) - unknown error.
                 ##      status = 100..505 - http response status, Note: 200 - OK!
                 ##      status > 12000 - wininet error code, see ERROR_INTERNET_*** in wininet.h
                 ## ```
    uri*: LPCWSTR              ## ```
                ##   requested url
                ## ```
  
  SCITER_CALLBACK_NOTIFICATION* {.bycopy.} = object ## ```
                                                ##   Notification callback structure.
                                                ## ```
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
  
  LPSCITER_CALLBACK_NOTIFICATION* = ptr SCITER_CALLBACK_NOTIFICATION
  SciterHostCallback* = proc (pns: LPSCITER_CALLBACK_NOTIFICATION;
                           callbackParam: LPVOID): cuint {.cdecl.}
  LPSciterHostCallback* = ptr SciterHostCallback
  SCN_LOAD_DATA* {.bycopy.} = object
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    uri*: LPCWSTR ## ```
                ##   < [in] Zero terminated string, fully qualified uri, for example "http:server/folder/file.ext".
                ## ```
    outData*: LPCBYTE ## ```
                    ##   < [in,out] pointer to loaded data to return. if data exists in the cache then this field contain pointer to it
                    ## ```
    outDataSize*: cuint        ## ```
                      ##   < [in,out] loaded data size to return.
                      ## ```
    dataType*: cuint           ## ```
                   ##   < [in] SciterResourceType
                   ## ```
    requestId*: HREQUEST ## ```
                       ##   < [in] request handle that can be used with sciter-x-request API
                       ## ```
    principal*: HELEMENT
    initiator*: HELEMENT

  LPSCN_LOAD_DATA* = ptr SCN_LOAD_DATA
  SCN_DATA_LOADED* {.bycopy.} = object ## ```
                                   ##   This structure is used by #SC_DATA_LOADED notification.
                                   ##   \copydoc SC_DATA_LOADED
                                   ## ```
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    uri*: LPCWSTR ## ```
                ##   < [in] zero terminated string, fully qualified uri, for example "http:server/folder/file.ext".
                ## ```
    data*: LPCBYTE             ## ```
                 ##   < [in] pointer to loaded data.
                 ## ```
    dataSize*: cuint           ## ```
                   ##   < [in] loaded data size (in bytes).
                   ## ```
    dataType*: cuint           ## ```
                   ##   < [in] SciterResourceType
                   ## ```
    status*: cuint ## ```
                 ##   < [in]
                 ##                                            status = 0 (dataSize == 0) - unknown error.
                 ##                                            status = 100..505 - http response status, Note: 200 - OK!
                 ##                                            status > 12000 - wininet error code, see ERROR_INTERNET_*** in wininet.h
                 ## ```
  
  LPSCN_DATA_LOADED* = ptr SCN_DATA_LOADED
  SCN_ATTACH_BEHAVIOR* {.bycopy.} = object ## ```
                                       ##   This structure is used by #SC_ATTACH_BEHAVIOR notification.
                                       ##   \copydoc SC_ATTACH_BEHAVIOR
                                       ## ```
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    element*: HELEMENT         ## ```
                     ##   < [in] target DOM element handle
                     ## ```
    behaviorName*: LPCSTR ## ```
                        ##   < [in] zero terminated string, string appears as value of CSS behavior:"???" attribute.
                        ## ```
    elementProc*: ElementEventProc ## ```
                                    ##   < [out] pointer to ElementEventProc function.
                                    ## ```
    elementTag*: LPVOID ## ```
                      ##   < [out] tag value, passed as is into pointer ElementEventProc function.
                      ## ```
  
  LPSCN_ATTACH_BEHAVIOR* = ptr SCN_ATTACH_BEHAVIOR
  SCN_ENGINE_DESTROYED* {.bycopy.} = object ## ```
                                        ##   This structure is used by #SC_ENGINE_DESTROYED notification.
                                        ##   \copydoc SC_ENGINE_DESTROYED
                                        ## ```
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
  
  LPSCN_ENGINE_DESTROYED* = ptr SCN_ENGINE_DESTROYED
  SCN_POSTED_NOTIFICATION* {.bycopy.} = object ## ```
                                           ##   This structure is used by #SC_ENGINE_DESTROYED notification.
                                           ##   \copydoc SC_ENGINE_DESTROYED
                                           ## ```
    code*: cuint               ## ```
               ##   < [in] one of the codes above.
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    wparam*: UINT_PTR ## ```
                    ##   < [in] HWINDOW of the window this callback was attached to.
                    ## ```
    lparam*: UINT_PTR
    lreturn*: UINT_PTR

  LPSCN_POSTED_NOTIFICATION* = ptr SCN_POSTED_NOTIFICATION
  SCN_GRAPHICS_CRITICAL_FAILURE* {.bycopy.} = object ## ```
                                                 ##   This structure is used by #SC_GRAPHICS_CRITICAL_FAILURE notification.
                                                 ##   \copydoc SC_GRAPHICS_CRITICAL_FAILURE
                                                 ## ```
    code*: cuint               ## ```
               ##   < [in] = SC_GRAPHICS_CRITICAL_FAILURE
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
  
  LPSCN_GRAPHICS_CRITICAL_FAILURE* = ptr SCN_GRAPHICS_CRITICAL_FAILURE
  SCN_KEYBOARD_REQUEST* {.bycopy.} = object ## ```
                                        ##   This structure is used by #SC_KEYBOARD_REQUEST notification.
                                        ##   \copydoc SC_KEYBOARD_REQUEST
                                        ## ```
    code*: cuint               ## ```
               ##   < [in] = SC_KEYBOARD_REQUEST
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    keyboardMode*: cuint ## ```
                       ##   < [in] 0 - hide keyboard, 1 ... type of keyboard, TBD
                       ## ```
  
  LPSCN_KEYBOARD_REQUEST* = ptr SCN_KEYBOARD_REQUEST
  SCN_INVALIDATE_RECT* {.bycopy.} = object ## ```
                                       ##   This structure is used by #SC_INVALIDATE_RECT notification.
                                       ##   \copydoc SC_INVALIDATE_RECT
                                       ## ```
    code*: cuint               ## ```
               ##   < [in] = SC_INVALIDATE_RECT
               ## ```
    hwnd*: ptr GtkWidget ## ```
                      ##   < [in] HWINDOW of the window this callback was attached to.
                      ## ```
    invalidRect*: RECT         ## ```
                     ##   < [in] cumulative invalid rect.
                     ## ```
  
  LPSCN_INVALIDATE_RECT* = ptr SCN_INVALIDATE_RECT
  URL_DATA* {.bycopy.} = object
    requestedUrl*: LPCSTR      ## ```
                        ##   requested URL
                        ## ```
    realUrl*: LPCSTR ## ```
                   ##   real URL data arrived from (after possible redirections)
                   ## ```
    requestedType*: SciterResourceType ## ```
                                     ##   requested data category: html, script, image, etc.
                                     ## ```
    httpHeaders*: LPCSTR       ## ```
                       ##   if any
                       ## ```
    mimeType*: LPCSTR          ## ```
                    ##   mime type reported by server (if any)
                    ## ```
    encoding*: LPCSTR          ## ```
                    ##   data encoding (if any)
                    ## ```
    data*: LPCBYTE             ## ```
                 ##   data encoding (if any)
                 ## ```
    dataLength*: cuint

  URL_DATA_RECEIVER* = proc (pUrlData: ptr URL_DATA; param: LPVOID): VOID {.cdecl.}
  SciterWindowDelegate* = LPVOID
  DEBUG_OUTPUT_PROC* = proc (param: LPVOID; subsystem: cuint; severity: cuint;
                          text: LPCWSTR; text_length: cuint): VOID {.cdecl.}
  SCITER_X_MSG* {.bycopy.} = object ## ```
                                ##   #SCITER_X_MSG common header of message structures passed to SciterProcX
                                ## ```
    msg*: cuint                ## ```
              ##   < [in]  one of the codes of #SCITER_X_MSG_CODE.
              ## ```
  
  SCITER_X_MSG_CREATE* {.bycopy.} = object
    header*: SCITER_X_MSG
    backend*: cuint
    transparent*: bool

  SCITER_X_MSG_DESTROY* {.bycopy.} = object
    header*: SCITER_X_MSG

  SCITER_X_MSG_SIZE* {.bycopy.} = object
    header*: SCITER_X_MSG
    width*: cuint
    height*: cuint

  SCITER_X_MSG_RESOLUTION* {.bycopy.} = object
    header*: SCITER_X_MSG
    pixelsPerInch*: cuint

  SCITER_X_MSG_MOUSE* {.bycopy.} = object
    header*: SCITER_X_MSG
    event*: MOUSE_EVENTS
    button*: MOUSE_BUTTONS
    modifiers*: KEYBOARD_STATES
    pos*: POINT

  SCITER_X_MSG_KEY* {.bycopy.} = object
    header*: SCITER_X_MSG
    event*: KEY_EVENTS
    code*: cuint
    modifiers*: KEYBOARD_STATES

  SCITER_X_MSG_FOCUS* {.bycopy.} = object
    header*: SCITER_X_MSG
    got*: bool                 ## ```
             ##   true - got, false - lost
             ## ```
  
  SCITER_X_MSG_HEARTBIT* {.bycopy.} = object
    header*: SCITER_X_MSG
    time*: cuint

  ELEMENT_BITMAP_RECEIVER* = proc (rgba: LPCBYTE; x: INT; y: INT; width: cuint;
                                height: cuint; param: LPVOID): VOID {.cdecl.}
  Type_sciterxh1* {.bycopy.} = object ## ```
                                  ##   < [in] must be IDXGISurface*
                                  ## ```
    param*: ptr VOID
    callback*: ptr ELEMENT_BITMAP_RECEIVER

  Union_sciterxh2* {.union, bycopy.} = object ## ```
                                         ##   < [in] one of #SCITER_PAINT_TARGET_TYPE values
                                         ## ```
    pSurface*: LPVOID          ## ```
                    ##   < [in] must be IDXGISurface*
                    ## ```
    receiver*: Type_sciterxh1  ## ```
                            ##   < [in] must be IDXGISurface*
                            ## ```
  
  SCITER_X_MSG_PAINT* {.bycopy.} = object
    header*: SCITER_X_MSG
    element*: HELEMENT ## ```
                     ##   < [in] layer #HELEMENT, can be NULL if whole tree (document) needs to be rendered.
                     ## ```
    isFore*: bool ## ```
                ##   < [in] if element is not null tells if that element is fore-layer.
                ## ```
    targetType*: cuint         ## ```
                     ##   < [in] one of #SCITER_PAINT_TARGET_TYPE values
                     ## ```
    target*: Union_sciterxh2   ## ```
                           ##   < [in] one of #SCITER_PAINT_TARGET_TYPE values
                           ## ```
  
  ISciterAPI* {.bycopy.} = object
    version*: cuint            ## ```
                  ##   API_VERSION
                  ## ```
    SciterClassName*: proc (): LPCWSTR {.cdecl.}
    SciterVersion*: proc (major: bool): cuint {.cdecl.}
    SciterDataReady*: proc (hwnd: ptr GtkWidget; uri: LPCWSTR; data: LPCBYTE;
                          dataLength: cuint): bool {.cdecl.}
    SciterDataReadyAsync*: proc (hwnd: ptr GtkWidget; uri: LPCWSTR; data: LPCBYTE;
                               dataLength: cuint; requestId: LPVOID): bool {.cdecl.}
    SciterLoadFile*: proc (hWndSciter: ptr GtkWidget; filename: LPCWSTR): bool {.cdecl.}
    SciterLoadHtml*: proc (hWndSciter: ptr GtkWidget; html: LPCBYTE; htmlSize: cuint;
                         baseUrl: LPCWSTR): bool {.cdecl.}
    SciterSetCallback*: proc (hWndSciter: ptr GtkWidget; cb: LPSciterHostCallback;
                            cbParam: LPVOID): VOID {.cdecl.}
    SciterSetMasterCSS*: proc (utf8: LPCBYTE; numBytes: cuint): bool {.cdecl.}
    SciterAppendMasterCSS*: proc (utf8: LPCBYTE; numBytes: cuint): bool {.cdecl.}
    SciterSetCSS*: proc (hWndSciter: ptr GtkWidget; utf8: LPCBYTE; numBytes: cuint;
                       baseUrl: LPCWSTR; mediaType: LPCWSTR): bool {.cdecl.}
    SciterSetMediaType*: proc (hWndSciter: ptr GtkWidget; mediaType: LPCWSTR): bool {.
        cdecl.}
    SciterSetMediaVars*: proc (hWndSciter: ptr GtkWidget; mediaVars: ptr SCITER_VALUE): bool {.
        cdecl.}
    SciterGetMinWidth*: proc (hWndSciter: ptr GtkWidget): cuint {.cdecl.}
    SciterGetMinHeight*: proc (hWndSciter: ptr GtkWidget; width: cuint): cuint {.cdecl.}
    SciterCall*: proc (hWnd: ptr GtkWidget; functionName: LPCSTR; argc: cuint;
                     argv: ptr SCITER_VALUE; retval: ptr SCITER_VALUE): bool {.cdecl.}
    SciterEval*: proc (hwnd: ptr GtkWidget; script: LPCWSTR; scriptLength: cuint;
                     pretval: ptr SCITER_VALUE): bool {.cdecl.}
    SciterUpdateWindow*: proc (hwnd: ptr GtkWidget): VOID {.cdecl.}
    SciterSetOption*: proc (hWnd: ptr GtkWidget; option: cuint; value: UINT_PTR): bool {.
        cdecl.}
    SciterGetPPI*: proc (hWndSciter: ptr GtkWidget; px: ptr cuint; py: ptr cuint): VOID {.
        cdecl.}
    SciterGetViewExpando*: proc (hwnd: ptr GtkWidget; pval: ptr VALUE): bool {.cdecl.}
    SciterGraphicsCaps*: proc (pcaps: LPUINT): bool {.cdecl.}
    SciterSetHomeURL*: proc (hWndSciter: ptr GtkWidget; baseUrl: LPCWSTR): bool {.cdecl.}
    SciterCreateWidget*: proc (frame: LPRECT): ptr GtkWidget {.cdecl.} ## ```
                                                                ##   returns GtkWidget
                                                                ## ```
    SciterCreateWindow*: proc (creationFlags: cuint; frame: LPRECT;
                             delegate: SciterWindowDelegate;
                             delegateParam: LPVOID; parent: ptr GtkWidget): ptr GtkWidget {.
        cdecl.}
    SciterSetupDebugOutput*: proc (hwndOrNull: ptr GtkWidget; param: LPVOID;
                                 pfOutput: DEBUG_OUTPUT_PROC): VOID {.cdecl.}
    Sciter_UseElement*: proc (he: HELEMENT): INT {.cdecl.} ## ```
                                                     ##   |
                                                     ##     | DOM Element API
                                                     ##     |
                                                     ## ```
    Sciter_UnuseElement*: proc (he: HELEMENT): INT {.cdecl.}
    SciterGetRootElement*: proc (hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.cdecl.}
    SciterGetFocusElement*: proc (hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.cdecl.}
    SciterFindElement*: proc (hwnd: ptr GtkWidget; pt: POINT; phe: ptr HELEMENT): INT {.
        cdecl.}
    SciterGetChildrenCount*: proc (he: HELEMENT; count: ptr cuint): INT {.cdecl.}
    SciterGetNthChild*: proc (he: HELEMENT; n: cuint; phe: ptr HELEMENT): INT {.cdecl.}
    SciterGetParentElement*: proc (he: HELEMENT; p_parent_he: ptr HELEMENT): INT {.cdecl.}
    SciterGetElementHtmlCB*: proc (he: HELEMENT; outer: bool;
                                 rcv: LPCBYTE_RECEIVER; rcv_param: LPVOID): INT {.
        cdecl.}
    SciterGetElementTextCB*: proc (he: HELEMENT; rcv: LPCWSTR_RECEIVER;
                                 rcv_param: LPVOID): INT {.cdecl.}
    SciterSetElementText*: proc (he: HELEMENT; utf16: LPCWSTR; length: cuint): INT {.
        cdecl.}
    SciterGetAttributeCount*: proc (he: HELEMENT; p_count: LPUINT): INT {.cdecl.}
    SciterGetNthAttributeNameCB*: proc (he: HELEMENT; n: cuint;
                                      rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): INT {.
        cdecl.}
    SciterGetNthAttributeValueCB*: proc (he: HELEMENT; n: cuint;
                                       rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
        cdecl.}
    SciterGetAttributeByNameCB*: proc (he: HELEMENT; name: LPCSTR;
                                     rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
        cdecl.}
    SciterSetAttributeByName*: proc (he: HELEMENT; name: LPCSTR; value: LPCWSTR): INT {.
        cdecl.}
    SciterClearAttributes*: proc (he: HELEMENT): INT {.cdecl.}
    SciterGetElementIndex*: proc (he: HELEMENT; p_index: LPUINT): INT {.cdecl.}
    SciterGetElementType*: proc (he: HELEMENT; p_type: ptr LPCSTR): INT {.cdecl.}
    SciterGetElementTypeCB*: proc (he: HELEMENT; rcv: LPCSTR_RECEIVER;
                                 rcv_param: LPVOID): INT {.cdecl.}
    SciterGetStyleAttributeCB*: proc (he: HELEMENT; name: LPCSTR;
                                    rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
        cdecl.}
    SciterSetStyleAttribute*: proc (he: HELEMENT; name: LPCSTR; value: LPCWSTR): INT {.
        cdecl.}
    SciterGetElementLocation*: proc (he: HELEMENT; p_location: LPRECT; areas: cuint): INT {.
        cdecl.}
    SciterScrollToView*: proc (he: HELEMENT; SciterScrollFlags: cuint): INT {.cdecl.}
    SciterUpdateElement*: proc (he: HELEMENT; andForceRender: bool): INT {.cdecl.}
    SciterRefreshElementArea*: proc (he: HELEMENT; rc: RECT): INT {.cdecl.}
    SciterSetCapture*: proc (he: HELEMENT): INT {.cdecl.}
    SciterReleaseCapture*: proc (he: HELEMENT): INT {.cdecl.}
    SciterGetElementHwnd*: proc (he: HELEMENT; p_hwnd: ptr ptr GtkWidget;
                               rootWindow: bool): INT {.cdecl.}
    SciterCombineURL*: proc (he: HELEMENT; szUrlBuffer: LPWSTR; UrlBufferSize: cuint): INT {.
        cdecl.}
    SciterSelectElements*: proc (he: HELEMENT; CSS_selectors: LPCSTR;
                               callback: SciterElementCallback; param: LPVOID): INT {.
        cdecl.}
    SciterSelectElementsW*: proc (he: HELEMENT; CSS_selectors: LPCWSTR;
                                callback: SciterElementCallback; param: LPVOID): INT {.
        cdecl.}
    SciterSelectParent*: proc (he: HELEMENT; selector: LPCSTR; depth: cuint;
                             heFound: ptr HELEMENT): INT {.cdecl.}
    SciterSelectParentW*: proc (he: HELEMENT; selector: LPCWSTR; depth: cuint;
                              heFound: ptr HELEMENT): INT {.cdecl.}
    SciterSetElementHtml*: proc (he: HELEMENT; html: ptr BYTE; htmlLength: cuint;
                               where: cuint): INT {.cdecl.}
    SciterGetElementUID*: proc (he: HELEMENT; puid: ptr cuint): INT {.cdecl.}
    SciterGetElementByUID*: proc (hwnd: ptr GtkWidget; uid: cuint; phe: ptr HELEMENT): INT {.
        cdecl.}
    SciterShowPopup*: proc (hePopup: HELEMENT; heAnchor: HELEMENT; placement: cuint): INT {.
        cdecl.}
    SciterShowPopupAt*: proc (hePopup: HELEMENT; pos: POINT; placement: cuint): INT {.
        cdecl.}
    SciterHidePopup*: proc (he: HELEMENT): INT {.cdecl.}
    SciterGetElementState*: proc (he: HELEMENT; pstateBits: ptr cuint): INT {.cdecl.}
    SciterSetElementState*: proc (he: HELEMENT; stateBitsToSet: cuint;
                                stateBitsToClear: cuint; updateView: bool): INT {.
        cdecl.}
    SciterCreateElement*: proc (tagname: LPCSTR; textOrNull: LPCWSTR;
                              phe: ptr HELEMENT): INT {.cdecl.}
    SciterCloneElement*: proc (he: HELEMENT; phe: ptr HELEMENT): INT {.cdecl.}
    SciterInsertElement*: proc (he: HELEMENT; hparent: HELEMENT; index: cuint): INT {.
        cdecl.}
    SciterDetachElement*: proc (he: HELEMENT): INT {.cdecl.}
    SciterDeleteElement*: proc (he: HELEMENT): INT {.cdecl.}
    SciterSetTimer*: proc (he: HELEMENT; milliseconds: cuint; timer_id: UINT_PTR): INT {.
        cdecl.}
    SciterDetachEventHandler*: proc (he: HELEMENT; pep: C_LPELEMENT_EVENT_PROC;
                                   tag: LPVOID): INT {.cdecl.}
    SciterAttachEventHandler*: proc (he: HELEMENT; pep: C_LPELEMENT_EVENT_PROC;
                                   tag: LPVOID): INT {.cdecl.}
    SciterWindowAttachEventHandler*: proc (hwndLayout: ptr GtkWidget;
        pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID; subscription: cuint): INT {.cdecl.}
    SciterWindowDetachEventHandler*: proc (hwndLayout: ptr GtkWidget;
        pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID): INT {.cdecl.}
    SciterSendEvent*: proc (he: HELEMENT; appEventCode: cuint; heSource: HELEMENT;
                          reason: UINT_PTR; handled: ptr bool): INT {.cdecl.}
    SciterPostEvent*: proc (he: HELEMENT; appEventCode: cuint; heSource: HELEMENT;
                          reason: UINT_PTR): INT {.cdecl.}
    SciterCallBehaviorMethod*: proc (he: HELEMENT; params: ptr METHOD_PARAMS): INT {.
        cdecl.}
    SciterRequestElementData*: proc (he: HELEMENT; url: LPCWSTR; dataType: cuint;
                                   initiator: HELEMENT): INT {.cdecl.}
    SciterHttpRequest*: proc (he: HELEMENT; url: LPCWSTR; dataType: cuint;
                            requestType: cuint; requestParams: ptr REQUEST_PARAM;
                            nParams: cuint): INT {.cdecl.}
    SciterGetScrollInfo*: proc (he: HELEMENT; scrollPos: LPPOINT; viewRect: LPRECT;
                              contentSize: LPSIZE): INT {.cdecl.}
    SciterSetScrollPos*: proc (he: HELEMENT; scrollPos: POINT; smooth: bool): INT {.cdecl.}
    SciterGetElementIntrinsicWidths*: proc (he: HELEMENT; pMinWidth: ptr INT;
        pMaxWidth: ptr INT): INT {.cdecl.}
    SciterGetElementIntrinsicHeight*: proc (he: HELEMENT; forWidth: INT;
        pHeight: ptr INT): INT {.cdecl.}
    SciterIsElementVisible*: proc (he: HELEMENT; pVisible: ptr bool): INT {.cdecl.}
    SciterIsElementEnabled*: proc (he: HELEMENT; pEnabled: ptr bool): INT {.cdecl.}
    SciterSortElements*: proc (he: HELEMENT; firstIndex: cuint; lastIndex: cuint;
                             cmpFunc: ptr ELEMENT_COMPARATOR; cmpFuncParam: LPVOID): INT {.
        cdecl.}
    SciterSwapElements*: proc (he1: HELEMENT; he2: HELEMENT): INT {.cdecl.}
    SciterTraverseUIEvent*: proc (evt: cuint; eventCtlStruct: LPVOID;
                                bOutProcessed: ptr bool): INT {.cdecl.}
    SciterCallScriptingMethod*: proc (he: HELEMENT; name: LPCSTR; argv: ptr VALUE;
                                    argc: cuint; retval: ptr VALUE): INT {.cdecl.}
    SciterCallScriptingFunction*: proc (he: HELEMENT; name: LPCSTR; argv: ptr VALUE;
                                      argc: cuint; retval: ptr VALUE): INT {.cdecl.}
    SciterEvalElementScript*: proc (he: HELEMENT; script: LPCWSTR;
                                  scriptLength: cuint; retval: ptr VALUE): INT {.cdecl.}
    SciterAttachHwndToElement*: proc (he: HELEMENT; hwnd: ptr GtkWidget): INT {.cdecl.}
    SciterControlGetType*: proc (he: HELEMENT; pType: ptr cuint): INT {.cdecl.}
    SciterGetValue*: proc (he: HELEMENT; pval: ptr VALUE): INT {.cdecl.}
    SciterSetValue*: proc (he: HELEMENT; pval: ptr VALUE): INT {.cdecl.}
    SciterGetExpando*: proc (he: HELEMENT; pval: ptr VALUE; forceCreation: bool): INT {.
        cdecl.}
    SciterGetObject*: proc (he: HELEMENT; pval: pointer; forceCreation: bool): INT {.
        cdecl.}
    SciterGetElementNamespace*: proc (he: HELEMENT; pval: pointer): INT {.cdecl.}
    SciterGetHighlightedElement*: proc (hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.
        cdecl.}
    SciterSetHighlightedElement*: proc (hwnd: ptr GtkWidget; he: HELEMENT): INT {.cdecl.} ## ```
                                                                                 ##   |
                                                                                 ##     | DOM Node API
                                                                                 ##     |
                                                                                 ## ```
    SciterNodeAddRef*: proc (hn: HNODE): INT {.cdecl.} ## ```
                                                 ##   |
                                                 ##     | DOM Node API
                                                 ##     |
                                                 ## ```
    SciterNodeRelease*: proc (hn: HNODE): INT {.cdecl.}
    SciterNodeCastFromElement*: proc (he: HELEMENT; phn: ptr HNODE): INT {.cdecl.}
    SciterNodeCastToElement*: proc (hn: HNODE; he: ptr HELEMENT): INT {.cdecl.}
    SciterNodeFirstChild*: proc (hn: HNODE; phn: ptr HNODE): INT {.cdecl.}
    SciterNodeLastChild*: proc (hn: HNODE; phn: ptr HNODE): INT {.cdecl.}
    SciterNodeNextSibling*: proc (hn: HNODE; phn: ptr HNODE): INT {.cdecl.}
    SciterNodePrevSibling*: proc (hn: HNODE; phn: ptr HNODE): INT {.cdecl.}
    SciterNodeParent*: proc (hnode: HNODE; pheParent: ptr HELEMENT): INT {.cdecl.}
    SciterNodeNthChild*: proc (hnode: HNODE; n: cuint; phn: ptr HNODE): INT {.cdecl.}
    SciterNodeChildrenCount*: proc (hnode: HNODE; pn: ptr cuint): INT {.cdecl.}
    SciterNodeType*: proc (hnode: HNODE; pNodeType: ptr cuint): INT {.cdecl.}
    SciterNodeGetText*: proc (hnode: HNODE; rcv: LPCWSTR_RECEIVER;
                            rcv_param: LPVOID): INT {.cdecl.}
    SciterNodeSetText*: proc (hnode: HNODE; text: LPCWSTR; textLength: cuint): INT {.
        cdecl.}
    SciterNodeInsert*: proc (hnode: HNODE; where: cuint; what: HNODE): INT {.cdecl.}
    SciterNodeRemove*: proc (hnode: HNODE; finalize: bool): INT {.cdecl.}
    SciterCreateTextNode*: proc (text: LPCWSTR; textLength: cuint; phnode: ptr HNODE): INT {.
        cdecl.}
    SciterCreateCommentNode*: proc (text: LPCWSTR; textLength: cuint;
                                  phnode: ptr HNODE): INT {.cdecl.} ## ```
                                                               ##   |
                                                               ##     | Value API
                                                               ##     |
                                                               ## ```
    ValueInit*: proc (pval: ptr VALUE): cuint {.cdecl.} ## ```
                                                 ##   |
                                                 ##     | Value API
                                                 ##     |
                                                 ## ```
    ValueClear*: proc (pval: ptr VALUE): cuint {.cdecl.}
    ValueCompare*: proc (pval1: ptr VALUE; pval2: ptr VALUE): cuint {.cdecl.}
    ValueCopy*: proc (pdst: ptr VALUE; psrc: ptr VALUE): cuint {.cdecl.}
    ValueIsolate*: proc (pdst: ptr VALUE): cuint {.cdecl.}
    ValueType*: proc (pval: ptr VALUE; pType: ptr cuint; pUnits: ptr cuint): cuint {.cdecl.}
    ValueStringData*: proc (pval: ptr VALUE; pChars: ptr LPCWSTR; pNumChars: ptr cuint): cuint {.
        cdecl.}
    ValueStringDataSet*: proc (pval: ptr VALUE; chars: LPCWSTR; numChars: cuint;
                             units: cuint): cuint {.cdecl.}
    ValueIntData*: proc (pval: ptr VALUE; pData: ptr INT): cuint {.cdecl.}
    ValueIntDataSet*: proc (pval: ptr VALUE; data: INT; `type`: cuint; units: cuint): cuint {.
        cdecl.}
    ValueInt64Data*: proc (pval: ptr VALUE; pData: ptr INT64): cuint {.cdecl.}
    ValueInt64DataSet*: proc (pval: ptr VALUE; data: INT64; `type`: cuint; units: cuint): cuint {.
        cdecl.}
    ValueFloatData*: proc (pval: ptr VALUE; pData: ptr cdouble): cuint {.cdecl.}
    ValueFloatDataSet*: proc (pval: ptr VALUE; data: cdouble; `type`: cuint; units: cuint): cuint {.
        cdecl.}
    ValueBinaryData*: proc (pval: ptr VALUE; pBytes: ptr LPCBYTE; pnBytes: ptr cuint): cuint {.
        cdecl.}
    ValueBinaryDataSet*: proc (pval: ptr VALUE; pBytes: LPCBYTE; nBytes: cuint;
                             `type`: cuint; units: cuint): cuint {.cdecl.}
    ValueElementsCount*: proc (pval: ptr VALUE; pn: ptr INT): cuint {.cdecl.}
    ValueNthElementValue*: proc (pval: ptr VALUE; n: INT; pretval: ptr VALUE): cuint {.
        cdecl.}
    ValueNthElementValueSet*: proc (pval: ptr VALUE; n: INT; pval_to_set: ptr VALUE): cuint {.
        cdecl.}
    ValueNthElementKey*: proc (pval: ptr VALUE; n: INT; pretval: ptr VALUE): cuint {.cdecl.}
    ValueEnumElements*: proc (pval: ptr VALUE; penum: KeyValueCallback;
                            param: LPVOID): cuint {.cdecl.}
    ValueSetValueToKey*: proc (pval: ptr VALUE; pkey: ptr VALUE; pval_to_set: ptr VALUE): cuint {.
        cdecl.}
    ValueGetValueOfKey*: proc (pval: ptr VALUE; pkey: ptr VALUE; pretval: ptr VALUE): cuint {.
        cdecl.}
    ValueToString*: proc (pval: ptr VALUE; how: cuint): cuint {.cdecl.}
    ValueFromString*: proc (pval: ptr VALUE; str: LPCWSTR; strLength: cuint; how: cuint): cuint {.
        cdecl.}
    ValueInvoke*: proc (pval: ptr VALUE; pthis: ptr VALUE; argc: cuint; argv: ptr VALUE;
                      pretval: ptr VALUE; url: LPCWSTR): cuint {.cdecl.}
    ValueNativeFunctorSet*: proc (pval: ptr VALUE;
                                pinvoke: NATIVE_FUNCTOR_INVOKE;
                                prelease: NATIVE_FUNCTOR_RELEASE; tag: ptr VOID): cuint {.
        cdecl.}
    ValueIsNativeFunctor*: proc (pval: ptr VALUE): bool {.cdecl.} ## ```
                                                           ##   used to be script VM API
                                                           ## ```
    reserved1*: LPVOID         ## ```
                     ##   used to be script VM API
                     ## ```
    reserved2*: LPVOID
    reserved3*: LPVOID
    reserved4*: LPVOID
    SciterOpenArchive*: proc (archiveData: LPCBYTE; archiveDataLength: cuint): HSARCHIVE {.
        cdecl.}
    SciterGetArchiveItem*: proc (harc: HSARCHIVE; path: LPCWSTR; pdata: ptr LPCBYTE;
                               pdataLength: ptr cuint): bool {.cdecl.}
    SciterCloseArchive*: proc (harc: HSARCHIVE): bool {.cdecl.}
    SciterFireEvent*: proc (evt: ptr BEHAVIOR_EVENT_PARAMS; post: bool;
                          handled: ptr bool): INT {.cdecl.}
    SciterGetCallbackParam*: proc (hwnd: ptr GtkWidget): LPVOID {.cdecl.}
    SciterPostCallback*: proc (hwnd: ptr GtkWidget; wparam: UINT_PTR; lparam: UINT_PTR;
                             timeoutms: cuint): UINT_PTR {.cdecl.}
    GetSciterGraphicsAPI*: proc (): LPSciterGraphicsAPI {.cdecl.}
    GetSciterRequestAPI*: proc (): LPSciterRequestAPI {.cdecl.}
    SciterProcX*: proc (hwnd: ptr GtkWidget; pMsg: ptr SCITER_X_MSG): bool {.cdecl.} ## ```
                                                                           ##   returns TRUE if handled
                                                                           ## ```
    SciterAtomValue*: proc (name: cstring): UINT64 {.cdecl.} ## ```
                                                       ##   
                                                       ## ```
    SciterAtomNameCB*: proc (atomv: UINT64; rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): bool {.
        cdecl.}               ## ```
               ##   
               ## ```
    SciterSetGlobalAsset*: proc (pass: ptr som_asset_t): bool {.cdecl.}

  SciterAPI_ptr* = proc (): ptr ISciterAPI {.cdecl.}
  SciterLibraryInitFunc* = proc (psapi: ptr ISciterAPI; plibobject: ptr SCITER_VALUE): bool {.
      cdecl.}
var
  left* {.importc.}: INT
  top* {.importc.}: INT
  right* {.importc.}: INT
  bottom* {.importc.}: INT
proc ValueInit*(pval: ptr VALUE): cuint {.importc, cdecl.}
  ## ```
  ##   ValueInit - initialize VALUE storage
  ##    This call has to be made before passing VALUE* to any other functions
  ## ```
proc ValueClear*(pval: ptr VALUE): cuint {.importc, cdecl.}
  ## ```
  ##   ValueClear - clears the VALUE and deallocates all assosiated structures that are not used anywhere else.
  ## ```
proc ValueCompare*(pval1: ptr VALUE; pval2: ptr VALUE): cuint {.importc, cdecl.}
  ## ```
  ##   ValueCompare - compares two values, returns HV_OK_TRUE if val1 == val2.
  ## ```
proc ValueCopy*(pdst: ptr VALUE; psrc: ptr VALUE): cuint {.importc, cdecl.}
  ## ```
  ##   ValueCopy - copies src VALUE to dst VALUE. dst VALUE must be in ValueInit state.
  ## ```
proc ValueIsolate*(pdst: ptr VALUE): cuint {.importc, cdecl.}
  ## ```
  ##   ValueIsolate - converts T_OBJECT value types to T_MAP or T_ARRAY.
  ##    use this method if you need to pass values between different threads.
  ##    The fanction is applicable for the Sciter
  ## ```
proc ValueType*(pval: ptr VALUE; pType: ptr cuint; pUnits: ptr cuint): cuint {.importc,
    cdecl.}
  ## ```
  ##   ValueType - returns VALUE_TYPE and VALUE_UNIT_TYPE flags of the VALUE
  ## ```
proc ValueStringData*(pval: ptr VALUE; pChars: ptr LPCWSTR; pNumChars: ptr cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueStringData - returns string data for T_STRING type
  ##    For T_FUNCTION returns name of the fuction.
  ## ```
proc ValueStringDataSet*(pval: ptr VALUE; chars: LPCWSTR; numChars: cuint; units: cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueStringDataSet - sets VALUE to T_STRING type and copies chars/numChars to
  ##    internal refcounted buffer assosiated with the value.
  ## ```
proc ValueIntData*(pval: ptr VALUE; pData: ptr INT): cuint {.importc, cdecl.}
  ## ```
  ##   ValueIntData - retreive integer data of T_INT, T_LENGTH and T_BOOL types
  ## ```
proc ValueIntDataSet*(pval: ptr VALUE; data: INT; `type`: cuint; units: cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueIntDataSet - sets VALUE integer data of T_INT and T_BOOL types 
  ##    Optionally sets units field too.
  ## ```
proc ValueInt64Data*(pval: ptr VALUE; pData: ptr INT64): cuint {.importc, cdecl.}
  ## ```
  ##   ValueInt64Data - retreive 64bit integer data of T_CURRENCY and T_DATE values.
  ## ```
proc ValueInt64DataSet*(pval: ptr VALUE; data: INT64; `type`: cuint; units: cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueInt64DataSet - sets 64bit integer data of T_CURRENCY and T_DATE values.
  ## ```
proc ValueFloatData*(pval: ptr VALUE; pData: ptr cdouble): cuint {.importc, cdecl.}
  ## ```
  ##   ValueFloatData - retreive FLOAT_VALUE (double) data of T_FLOAT and T_LENGTH values.
  ## ```
proc ValueFloatDataSet*(pval: ptr VALUE; data: cdouble; `type`: cuint; units: cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueFloatDataSet - sets FLOAT_VALUE data of T_FLOAT and T_LENGTH values.
  ## ```
proc ValueBinaryData*(pval: ptr VALUE; pBytes: ptr LPCBYTE; pnBytes: ptr cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueBinaryData - retreive integer data of T_BYTES type
  ## ```
proc ValueBinaryDataSet*(pval: ptr VALUE; pBytes: LPCBYTE; nBytes: cuint; `type`: cuint;
                        units: cuint): cuint {.importc, cdecl.}
  ## ```
  ##   ValueBinaryDataSet - sets VALUE to sequence of bytes of type T_BYTES 
  ##    'type' here must be set to T_BYTES. Optionally sets units field too.
  ##    The function creates local copy of bytes in its own storage.
  ## ```
proc ValueElementsCount*(pval: ptr VALUE; pn: ptr INT): cuint {.importc, cdecl.}
  ## ```
  ##   ValueElementsCount - retreive number of sub-elements for:
  ##    - T_ARRAY - number of elements in the array; 
  ##    - T_MAP - number of key/value pairs in the map;
  ##    - T_FUNCTION - number of arguments in the function;
  ## ```
proc ValueNthElementValue*(pval: ptr VALUE; n: INT; pretval: ptr VALUE): cuint {.importc,
    cdecl.}
  ## ```
  ##   ValueNthElementValue - retreive value of sub-element at index n for:
  ##    - T_ARRAY - nth element of the array; 
  ##    - T_MAP - value of nth key/value pair in the map;
  ##    - T_FUNCTION - value of nth argument of the function;
  ## ```
proc ValueNthElementValueSet*(pval: ptr VALUE; n: INT; pval_to_set: ptr VALUE): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueNthElementValueSet - sets value of sub-element at index n for:
  ##    - T_ARRAY - nth element of the array; 
  ##    - T_MAP - value of nth key/value pair in the map;
  ##    - T_FUNCTION - value of nth argument of the function;
  ##    If the VALUE is not of one of types above then it makes it of type T_ARRAY with 
  ##    single element - 'val_to_set'.
  ## ```
proc ValueNthElementKey*(pval: ptr VALUE; n: INT; pretval: ptr VALUE): cuint {.importc,
    cdecl.}
  ## ```
  ##   ValueEnumElements - enumeartes key/value pairs of T_MAP, T_FUNCTION and T_OBJECT values
  ##    - T_MAP - key of nth key/value pair in the map;
  ##    - T_FUNCTION - name of nth argument of the function (if any);
  ## ```
proc ValueEnumElements*(pval: ptr VALUE; penum: KeyValueCallback; param: LPVOID): cuint {.
    importc, cdecl.}
proc ValueSetValueToKey*(pval: ptr VALUE; pkey: ptr VALUE; pval_to_set: ptr VALUE): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueSetValueToKey - sets value of sub-element by key:
  ##    - T_MAP - value of key/value pair with the key;
  ##    - T_FUNCTION - value of argument with the name key;
  ##    - T_OBJECT (tiscript) - value of property of the object
  ##    If the VALUE is not of one of types above then it makes it of type T_MAP with 
  ##    single pair - 'key'/'val_to_set'.
  ##   
  ##    key usually is a value of type T_STRING
  ## ```
proc ValueGetValueOfKey*(pval: ptr VALUE; pkey: ptr VALUE; pretval: ptr VALUE): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueGetValueOfKey - retrieves value of sub-element by key:
  ##    - T_MAP - value of key/value pair with the key;
  ##    - T_FUNCTION - value of argument with the name key;
  ##    - T_OBJECT (tiscript) - value of property of the object
  ##    Otherwisepretval will have T_UNDEFINED value.
  ## ```
proc ValueToString*(pval: ptr VALUE; how: cuint): cuint {.importc, cdecl.}
  ## ```
  ##   ValueToString - converts value to T_STRING inplace:
  ##    - CVT_SIMPLE - parse/emit terminal values (T_INT, T_FLOAT, T_LENGTH, T_STRING)
  ##    - CVT_JSON_LITERAL - parse/emit value using JSON literal rules: {}, [], "string", true, false, null 
  ##    - CVT_JSON_MAP - parse/emit MAP value without enclosing '{' and '}' brackets.
  ## ```
proc ValueFromString*(pval: ptr VALUE; str: LPCWSTR; strLength: cuint; how: cuint): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueFromString - parses string into value:
  ##    - CVT_SIMPLE - parse/emit terminal values (T_INT, T_FLOAT, T_LENGTH, T_STRING), "guess" non-strict parsing
  ##    - CVT_JSON_LITERAL - parse/emit value using JSON literal rules: {}, [], "string", true, false, null 
  ##    - CVT_JSON_MAP - parse/emit MAP value without enclosing '{' and '}' brackets.
  ##    Returns:
  ##      Number of non-parsed characters in case of errors. Thus if string was parsed in full it returns 0 (success)
  ## ```
proc ValueInvoke*(pval: ptr VALUE; pthis: ptr VALUE; argc: cuint; argv: ptr VALUE;
                 pretval: ptr VALUE; url: LPCWSTR): cuint {.importc, cdecl.}
  ## ```
  ##   ValueInvoke - function invocation (Sciter/TIScript).
  ##    - VALUE* pval is a value of type T_OBJECT/UT_OBJECT_FUNCTION
  ##    - VALUE* pthis - object that will be known as 'this' inside that function.
  ##    - UINT argc, const VALUE* argv - vector of arguments to pass to the function. 
  ##    - VALUE* pretval - parse/emit MAP value without enclosing '{' and '}' brackets.
  ##    - LPCWSTR url - url or name of the script - used for error reporting in the script.
  ##    Returns:
  ##      HV_OK, HV_BAD_PARAMETER or HV_INCOMPATIBLE_TYPE
  ## ```
proc ValueNativeFunctorSet*(pval: ptr VALUE; pinvoke: NATIVE_FUNCTOR_INVOKE;
                           prelease: NATIVE_FUNCTOR_RELEASE; tag: ptr VOID): cuint {.
    importc, cdecl.}
  ## ```
  ##   ValueNativeFunctorSet - set reference to native function
  ##    - VALUE* pval - value to be initialized 
  ##    - NATIVE_FUNCTOR_INVOKE* pinvoke - reference to native functor implementation.
  ##    - NATIVE_FUNCTOR_RELEASE* prelease - reference to native functor dtor implementation.
  ##    - VOID* tag - optional tag, passed as it is to pinvoke and prelease
  ##    Returns:
  ##      HV_OK, HV_BAD_PARAMETER
  ## ```
proc ValueIsNativeFunctor*(pval: ptr VALUE): bool {.importc, cdecl.}
proc Sciter_UseElement*(he: HELEMENT): INT {.importc, cdecl.}
proc Sciter_UnuseElement*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Marks DOM object as unused (a.k.a. Release).
  ##    Get handle of every element's child element.
  ##    \param[in] he \b #HELEMENT
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    Application should call this function when it does not need element's
  ##    handle anymore.
  ##    \sa #Sciter_UseElement()
  ## ```
proc SciterGetRootElement*(hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Get root DOM element of HTML document.
  ##    \param[in] hwnd \b HWINDOW, Sciter window for which you need to get root
  ##    element
  ##    \param[out ] phe \b #HELEMENT*, variable to receive root element
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    Root DOM object is always a 'HTML' element of the document.
  ## ```
proc SciterGetFocusElement*(hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Get focused DOM element of HTML document.
  ##    \param[in] hwnd \b HWINDOW, Sciter window for which you need to get focus
  ##    element
  ##    \param[out ] phe \b #HELEMENT*, variable to receive focus element
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    phe can have null value (0).
  ##   
  ##    COMMENT: To set focus on element use SciterSetElementState(STATE_FOCUS,0)
  ## ```
proc SciterFindElement*(hwnd: ptr GtkWidget; pt: POINT; phe: ptr HELEMENT): INT {.importc,
    cdecl.}
  ## ```
  ##   Find DOM element by coordinate.
  ##    \param[in] hwnd \b HWINDOW, Sciter window for which you need to find
  ##    elementz
  ##    \param[in] pt \b POINT, coordinates, window client area relative.
  ##    \param[out ] phe \b #HELEMENT*, variable to receive found element handle.
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    If element was not found thenphe will be set to zero.
  ## ```
proc SciterGetChildrenCount*(he: HELEMENT; count: ptr cuint): INT {.importc, cdecl.}
  ## ```
  ##   Get number of child elements.
  ##    \param[in] he \b #HELEMENT, element which child elements you need to count
  ##    \param[out] count \b UINT*, variable to receive number of child elements
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    \par Example:
  ##    for paragraph defined as
  ##    \verbatim <p>Hello <b>wonderfull</b> world!</p> \endverbatim
  ##    count will be set to 1 as the paragraph has only one sub element:
  ##    \verbatim <b>wonderfull</b> \endverbatim
  ## ```
proc SciterGetNthChild*(he: HELEMENT; n: cuint; phe: ptr HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Get handle of every element's child element.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] n \b UINT, number of the child element
  ##    \param[out] phe \b #HELEMENT*, variable to receive handle of the child
  ##    element
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    \par Example:
  ##    for paragraph defined as
  ##    \verbatim <p>Hello <b>wonderfull</b> world!</p> \endverbatim
  ##   phe will be equal to handle of &lt;b&gt; element:
  ##    \verbatim <b>wonderfull</b> \endverbatim
  ## ```
proc SciterGetParentElement*(he: HELEMENT; p_parent_he: ptr HELEMENT): INT {.importc,
    cdecl.}
  ## ```
  ##   Get parent element.
  ##    \param[in] he \b #HELEMENT, element which parent you need
  ##    \param[out] p_parent_he \b #HELEMENT*, variable to recieve handle of the
  ##    parent element
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetElementHtmlCB*(he: HELEMENT; outer: bool; rcv: LPCBYTE_RECEIVER;
                            rcv_param: LPVOID): INT {.importc, cdecl.}
  ## ```
  ##   Get html representation of the element.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] outer \b BOOL, if TRUE will return outer HTML otherwise inner.
  ##    \param[in] rcv \b pointer to function receiving UTF8 encoded HTML.
  ##    \param[in] rcv_param \b parameter that passed to rcv as it is.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetElementTextCB*(he: HELEMENT; rcv: LPCWSTR_RECEIVER;
                            rcv_param: LPVOID): INT {.importc, cdecl.}
proc SciterSetElementText*(he: HELEMENT; utf16: LPCWSTR; length: cuint): INT {.importc,
    cdecl.}
  ## ```
  ##   Set inner text of the element from LPCWSTR buffer (utf16 words).
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] utf16words \b pointer, UTF16 encoded plain text
  ##    \param[in] length \b UINT, number of words in utf16words sequence
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetAttributeCount*(he: HELEMENT; p_count: LPUINT): INT {.importc, cdecl.}
  ## ```
  ##   Get number of element's attributes.
  ##    \param[in] he \b #HELEMENT
  ##    \param[out] p_count \b LPUINT, variable to receive number of element
  ##    attributes.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetNthAttributeNameCB*(he: HELEMENT; n: cuint; rcv: LPCSTR_RECEIVER;
                                 rcv_param: LPVOID): INT {.importc, cdecl.}
proc SciterGetNthAttributeValueCB*(he: HELEMENT; n: cuint; rcv: LPCWSTR_RECEIVER;
                                  rcv_param: LPVOID): INT {.importc, cdecl.}
proc SciterGetAttributeByNameCB*(he: HELEMENT; name: LPCSTR;
                                rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
    importc, cdecl.}
  ## ```
  ##   Get value of any element's attribute by name.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] name \b LPCSTR, attribute name
  ##    \param[out] p_value \b LPCWSTR*, will be set to address of the string
  ##    containing attribute value
  ##    \return \b #SCDOM_RESULT SCAPI
  ##    
  ##     SCDOM_RESULT SCAPI SciterGetAttributeByName(HELEMENT he, LPCSTR name, LPCWSTR* p_value);
  ## ```
proc SciterSetAttributeByName*(he: HELEMENT; name: LPCSTR; value: LPCWSTR): INT {.
    importc, cdecl.}
  ## ```
  ##   Set attribute's value.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] name \b LPCSTR, attribute name
  ##    \param[in] value \b LPCWSTR, new attribute value or 0 if you want to remove attribute.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterClearAttributes*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Remove all attributes from the element.
  ##    \param[in] he \b #HELEMENT
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetElementIndex*(he: HELEMENT; p_index: LPUINT): INT {.importc, cdecl.}
  ## ```
  ##   Get element index.
  ##    \param[in] he \b #HELEMENT
  ##    \param[out] p_index \b LPUINT, variable to receive number of the element
  ##    among parent element's subelements.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetElementType*(he: HELEMENT; p_type: ptr LPCSTR): INT {.importc, cdecl.}
  ## ```
  ##   Get element's type.
  ##    \param[in] he \b #HELEMENT
  ##    \param[out] p_type \b LPCSTR*, receives name of the element type.
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    \par Example:
  ##    For &lt;div&gt; tag p_type will be set to "div".
  ## ```
proc SciterGetElementTypeCB*(he: HELEMENT; rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): INT {.
    importc, cdecl.}
  ## ```
  ##   Get element's type.
  ##    \param[in] he \b #HELEMENT
  ##    \param[out] rcv \b LPCSTR_RECEIVER, receives name of the element type.
  ##    \param[out] rcv_param \b LPVOID, parameter passed as it is to the receiver.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterGetStyleAttributeCB*(he: HELEMENT; name: LPCSTR;
                               rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
    importc, cdecl.}
proc SciterSetStyleAttribute*(he: HELEMENT; name: LPCSTR; value: LPCWSTR): INT {.
    importc, cdecl.}
  ## ```
  ##   Get element's style attribute.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] name \b LPCSTR, name of the style attribute
  ##    \param[out] value \b LPCWSTR, value of the style attribute.
  ##   
  ##    Style attributes are those that are set using css. E.g. "font-face: arial" or "display: block".
  ##   
  ##    \sa #SciterGetStyleAttribute()
  ## ```
proc SciterGetElementLocation*(he: HELEMENT; p_location: LPRECT; areas: cuint): INT {.
    importc, cdecl.}
proc SciterScrollToView*(he: HELEMENT; SciterScrollFlags: cuint): INT {.importc, cdecl.}
  ## ```
  ##   Scroll to view.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] SciterScrollFlags \b #UINT, combination of SCITER_SCROLL_FLAGS above or 0
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterUpdateElement*(he: HELEMENT; andForceRender: bool): INT {.importc, cdecl.}
  ## ```
  ##   Apply changes and refresh element area in its window.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] andForceRender \b BOOL, TRUE to force UpdateWindow() call.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterRefreshElementArea*(he: HELEMENT; rc: RECT): INT {.importc, cdecl.}
  ## ```
  ##   refresh element area in its window.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] rc \b RECT, rect to refresh.
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterSetCapture*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Set the mouse capture to the specified element.
  ##    \param[in] he \b #HELEMENT
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    After call to this function all mouse events will be targeted to the element.
  ##    To remove mouse capture call ReleaseCapture() function.
  ## ```
proc SciterReleaseCapture*(he: HELEMENT): INT {.importc, cdecl.}
proc SciterGetElementHwnd*(he: HELEMENT; p_hwnd: ptr ptr GtkWidget; rootWindow: bool): INT {.
    importc, cdecl.}
  ## ```
  ##   Get HWINDOW of containing window.
  ##    \param[in] he \b #HELEMENT
  ##    \param[out] p_hwnd \b HWINDOW*, variable to receive window handle
  ##    \param[in] rootWindow \b BOOL, handle of which window to get:
  ##    - TRUE - Sciter window
  ##    - FALSE - nearest parent element having overflow:auto or :scroll
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterCombineURL*(he: HELEMENT; szUrlBuffer: LPWSTR; UrlBufferSize: cuint): INT {.
    importc, cdecl.}
  ## ```
  ##   Combine given URL with URL of the document element belongs to.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in, out] szUrlBuffer \b LPWSTR, at input this buffer contains
  ##    zero-terminated URL to be combined, after function call it contains
  ##    zero-terminated combined URL
  ##    \param[in] UrlBufferSize \b UINT, size of the buffer pointed by
  ##    \c szUrlBuffer
  ##    \return \b #SCDOM_RESULT SCAPI
  ##   
  ##    This function is used for resolving relative references.
  ## ```
proc SciterSelectElements*(he: HELEMENT; CSS_selectors: LPCSTR;
                          callback: SciterElementCallback; param: LPVOID): INT {.
    importc, cdecl.}
proc SciterSelectElementsW*(he: HELEMENT; CSS_selectors: LPCWSTR;
                           callback: SciterElementCallback; param: LPVOID): INT {.
    importc, cdecl.}
proc SciterSelectParent*(he: HELEMENT; selector: LPCSTR; depth: cuint;
                        heFound: ptr HELEMENT): INT {.importc, cdecl.}
proc SciterSelectParentW*(he: HELEMENT; selector: LPCWSTR; depth: cuint;
                         heFound: ptr HELEMENT): INT {.importc, cdecl.}
proc SciterSetElementHtml*(he: HELEMENT; html: ptr BYTE; htmlLength: cuint; where: cuint): INT {.
    importc, cdecl.}
proc SciterGetElementUID*(he: HELEMENT; puid: ptr cuint): INT {.importc, cdecl.}
proc SciterGetElementByUID*(hwnd: ptr GtkWidget; uid: cuint; phe: ptr HELEMENT): INT {.
    importc, cdecl.}
proc SciterShowPopup*(hePopup: HELEMENT; heAnchor: HELEMENT; placement: cuint): INT {.
    importc, cdecl.}
  ## ```
  ##   Shows block element (DIV) in popup window.
  ##    \param[in] hePopup \b HELEMENT, element to show as popup
  ##    \param[in] heAnchor \b HELEMENT, anchor element - hePopup will be shown near this element
  ##    \param[in] placement \b UINT, values:
  ##        2 - popup element below of anchor
  ##        8 - popup element above of anchor
  ##        4 - popup element on left side of anchor
  ##        6 - popup element on right side of anchor
  ##        ( see numpad on keyboard to get an idea of the numbers)
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterShowPopupAt*(hePopup: HELEMENT; pos: POINT; placement: cuint): INT {.importc,
    cdecl.}
proc SciterHidePopup*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Removes popup window.
  ##    \param[in] he \b HELEMENT, element which belongs to popup window or popup element itself
  ## ```
proc SciterGetElementState*(he: HELEMENT; pstateBits: ptr cuint): INT {.importc, cdecl.}
  ## ```
  ##   Get/set state bits, stateBits*** accept or'ed values above
  ## ```
proc SciterSetElementState*(he: HELEMENT; stateBitsToSet: cuint;
                           stateBitsToClear: cuint; updateView: bool): INT {.importc,
    cdecl.}
  ## ```
  ##   
  ## ```
proc SciterCreateElement*(tagname: LPCSTR; textOrNull: LPCWSTR; phe: ptr HELEMENT): INT {.
    importc, cdecl.}
proc SciterCloneElement*(he: HELEMENT; phe: ptr HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Create new element as copy of existing element, new element is a full (deep) copy of the element and
  ##       is disconnected initially from the DOM.
  ##       Element created with ref_count = 1 thus you \b must call Sciter_UnuseElement on returned handler.
  ##    \param[in] he \b #HELEMENT, source element.
  ##    \param[out ] phe \b #HELEMENT*, variable to receive handle of the new element.
  ## ```
proc SciterInsertElement*(he: HELEMENT; hparent: HELEMENT; index: cuint): INT {.importc,
    cdecl.}
proc SciterDetachElement*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Take element out of its container (and DOM tree).
  ##       Element will be destroyed when its reference counter will become zero
  ## ```
proc SciterDeleteElement*(he: HELEMENT): INT {.importc, cdecl.}
  ## ```
  ##   Take element out of its container (and DOM tree) and force destruction of all behaviors.
  ##       Element will be destroyed when its reference counter will become zero
  ## ```
proc SciterSetTimer*(he: HELEMENT; milliseconds: cuint; timer_id: UINT_PTR): INT {.
    importc, cdecl.}
  ## ```
  ##   Start Timer for the element.
  ##       Element will receive on_timer event
  ##       To stop timer call SciterSetTimer( he, 0 );
  ## ```
proc SciterDetachEventHandler*(he: HELEMENT; pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID): INT {.
    importc, cdecl.}
  ## ```
  ##   Attach/Detach ElementEventProc to the element
  ##       See sciter::event_handler.
  ## ```
proc SciterAttachEventHandler*(he: HELEMENT; pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID): INT {.
    importc, cdecl.}
  ## ```
  ##   Attach ElementEventProc to the element and subscribe it to events providede by subscription parameter
  ##       See Sciter::attach_event_handler.
  ## ```
proc SciterWindowAttachEventHandler*(hwndLayout: ptr GtkWidget;
                                    pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID;
                                    subscription: cuint): INT {.importc, cdecl.}
  ## ```
  ##   Attach/Detach ElementEventProc to the Sciter window.
  ##       All events will start first here (in SINKING phase) and if not consumed will end up here.
  ##       You can install Window EventHandler only once - it will survive all document reloads.
  ## ```
proc SciterWindowDetachEventHandler*(hwndLayout: ptr GtkWidget;
                                    pep: C_LPELEMENT_EVENT_PROC; tag: LPVOID): INT {.
    importc, cdecl.}
proc SciterSendEvent*(he: HELEMENT; appEventCode: cuint; heSource: HELEMENT;
                     reason: UINT_PTR; handled: ptr bool): INT {.importc, cdecl.}
proc SciterPostEvent*(he: HELEMENT; appEventCode: cuint; heSource: HELEMENT;
                     reason: UINT_PTR): INT {.importc, cdecl.}
proc SciterFireEvent*(evt: ptr BEHAVIOR_EVENT_PARAMS; post: bool; handled: ptr bool): INT {.
    importc, cdecl.}
proc SciterCallBehaviorMethod*(he: HELEMENT; params: ptr METHOD_PARAMS): INT {.importc,
    cdecl.}
proc SciterRequestElementData*(he: HELEMENT; url: LPCWSTR; dataType: cuint;
                              initiator: HELEMENT): INT {.importc, cdecl.}
proc SciterHttpRequest*(he: HELEMENT; url: LPCWSTR; dataType: cuint;
                       requestType: cuint; requestParams: ptr REQUEST_PARAM;
                       nParams: cuint): INT {.importc, cdecl.}
proc SciterGetScrollInfo*(he: HELEMENT; scrollPos: LPPOINT; viewRect: LPRECT;
                         contentSize: LPSIZE): INT {.importc, cdecl.}
proc SciterSetScrollPos*(he: HELEMENT; scrollPos: POINT; smooth: bool): INT {.importc,
    cdecl.}
proc SciterGetElementIntrinsicWidths*(he: HELEMENT; pMinWidth: ptr INT;
                                     pMaxWidth: ptr INT): INT {.importc, cdecl.}
  ## ```
  ##   SciterGetElementIntrinsicWidths  - get min-intrinsic and max-intrinsic widths of the element.
  ##    \param[in] he \b HELEMENT, element.
  ##    \param[out] pMinWidth \b INT*, calculated min-intrinsic width.
  ##    \param[out] pMaxWidth \b INT*, calculated max-intrinsic width.
  ## ```
proc SciterGetElementIntrinsicHeight*(he: HELEMENT; forWidth: INT; pHeight: ptr INT): INT {.
    importc, cdecl.}
  ## ```
  ##   SciterGetElementIntrinsicHeight  - get min-intrinsic height of the element calculated for forWidth.
  ##    \param[in] he \b HELEMENT, element.
  ##    \param[in] forWidth \b INT*, width to calculate intrinsic height for.
  ##    \param[out] pHeight \b INT*, calculated min-intrinsic height.
  ## ```
proc SciterIsElementVisible*(he: HELEMENT; pVisible: ptr bool): INT {.importc, cdecl.}
proc SciterIsElementEnabled*(he: HELEMENT; pEnabled: ptr bool): INT {.importc, cdecl.}
proc SciterSortElements*(he: HELEMENT; firstIndex: cuint; lastIndex: cuint;
                        cmpFunc: ptr ELEMENT_COMPARATOR; cmpFuncParam: LPVOID): INT {.
    importc, cdecl.}
proc SciterSwapElements*(he1: HELEMENT; he2: HELEMENT): INT {.importc, cdecl.}
proc SciterTraverseUIEvent*(evt: cuint; eventCtlStruct: LPVOID;
                           bOutProcessed: ptr bool): INT {.importc, cdecl.}
proc SciterCallScriptingMethod*(he: HELEMENT; name: LPCSTR; argv: ptr VALUE;
                               argc: cuint; retval: ptr VALUE): INT {.importc, cdecl.}
proc SciterCallScriptingFunction*(he: HELEMENT; name: LPCSTR; argv: ptr VALUE;
                                 argc: cuint; retval: ptr VALUE): INT {.importc, cdecl.}
proc SciterEvalElementScript*(he: HELEMENT; script: LPCWSTR; scriptLength: cuint;
                             retval: ptr VALUE): INT {.importc, cdecl.}
proc SciterAttachHwndToElement*(he: HELEMENT; hwnd: ptr GtkWidget): INT {.importc, cdecl.}
  ## ```
  ##   Attach HWINDOW to the element.
  ##    \param[in] he \b #HELEMENT
  ##    \param[in] hwnd \b HWINDOW, window handle to attach
  ##    \return \b #SCDOM_RESULT SCAPI
  ## ```
proc SciterControlGetType*(he: HELEMENT; pType: ptr cuint): INT {.importc, cdecl.}
  ## ```
  ##   SciterControlGetType - get type of control - type of behavior assigned to the element.
  ##    \param[in] he \b HELEMENT, element.
  ##    \param[out] pType \b UINT*, pointer to variable receiving control type,
  ##                for list of values see CTL_TYPE.
  ## ```
proc SciterGetValue*(he: HELEMENT; pval: ptr VALUE): INT {.importc, cdecl.}
  ## ```
  ##   SciterGetValue - get value of the element. 'value' is value of correspondent behavior attached to the element or its text.
  ##    \param[in] he \b HELEMENT, element which value will be retrieved.
  ##    \param[out] pval \b VALUE*, pointer to VALUE that will get elements value.
  ##     ATTN: if you are not using json::value wrapper then you shall call ValueClear aginst the returned value
  ##           otherwise memory will leak.
  ## ```
proc SciterSetValue*(he: HELEMENT; pval: ptr VALUE): INT {.importc, cdecl.}
  ## ```
  ##   SciterSetValue - set value of the element.
  ##    \param[in] he \b HELEMENT, element which value will be changed.
  ##    \param[in] pval \b VALUE*, pointer to the VALUE to set.
  ## ```
proc SciterGetExpando*(he: HELEMENT; pval: ptr VALUE; forceCreation: bool): INT {.
    importc, cdecl.}
  ## ```
  ##   SciterGetExpando - get 'expando' of the element. 'expando' is a scripting object (of class Element)
  ##     that is assigned to the DOM element. 'expando' could be null as they are created on demand by script.
  ##    \param[in] he \b HELEMENT, element which expando will be retrieved.
  ##    \param[out] pval \b VALUE*, pointer to VALUE that will get value of type T_OBJECT/UT_OBJECT_NATIVE or null.
  ##    \param[in] forceCreation \b BOOL, if there is no expando then when forceCreation==TRUE the function will create it.
  ##     ATTN: if you are not using json::value wrapper then you shall call ValueClear aginst the returned value
  ##           otherwise it will leak memory.
  ## ```
proc SciterGetObject*(he: HELEMENT; pval: pointer; forceCreation: bool): INT {.importc,
    cdecl.}
  ## ```
  ##   SciterGetObject - get 'expando' object of the element. 'expando' is a scripting object (of class Element)
  ##     that is assigned to the DOM element. 'expando' could be null as they are created on demand by script.
  ##    \param[in] he \b HELEMENT, element which expando will be retrieved.
  ##    \param[out] pval \b tiscript::value*, pointer to tiscript::value that will get reference to the scripting object associated wuth the element or null.
  ##    \param[in] forceCreation \b BOOL, if there is no expando then when forceCreation==TRUE the function will create it.
  ##   
  ##     ATTN!: if you plan to store the reference or use it inside code that calls script VM functions
  ##            then you should use tiscript::pinned holder for the value.
  ## ```
proc SciterGetElementNamespace*(he: HELEMENT; pval: pointer): INT {.importc, cdecl.}
proc SciterGetHighlightedElement*(hwnd: ptr GtkWidget; phe: ptr HELEMENT): INT {.
    importc, cdecl.}
  ## ```
  ##   get/set highlighted element. Used for debugging purposes.
  ## ```
proc SciterSetHighlightedElement*(hwnd: ptr GtkWidget; he: HELEMENT): INT {.importc,
    cdecl.}
proc SciterNodeAddRef*(hn: HNODE): INT {.importc, cdecl.}
proc SciterNodeRelease*(hn: HNODE): INT {.importc, cdecl.}
proc SciterNodeCastFromElement*(he: HELEMENT; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodeCastToElement*(hn: HNODE; he: ptr HELEMENT): INT {.importc, cdecl.}
proc SciterNodeFirstChild*(hn: HNODE; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodeLastChild*(hn: HNODE; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodeNextSibling*(hn: HNODE; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodePrevSibling*(hn: HNODE; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodeParent*(hnode: HNODE; pheParent: ptr HELEMENT): INT {.importc, cdecl.}
proc SciterNodeNthChild*(hnode: HNODE; n: cuint; phn: ptr HNODE): INT {.importc, cdecl.}
proc SciterNodeChildrenCount*(hnode: HNODE; pn: ptr cuint): INT {.importc, cdecl.}
proc SciterNodeType*(hnode: HNODE; pNodeType: ptr cuint): INT {.importc, cdecl.}
proc SciterNodeGetText*(hnode: HNODE; rcv: LPCWSTR_RECEIVER; rcv_param: LPVOID): INT {.
    importc, cdecl.}
proc SciterNodeSetText*(hnode: HNODE; text: LPCWSTR; textLength: cuint): INT {.importc,
    cdecl.}
proc SciterNodeInsert*(hnode: HNODE; where: cuint; what: HNODE): INT {.importc, cdecl.}
  ## ```
  ##   remove the node from the DOM, use finalize=FALSE if you plan to attach the node to the DOM later.
  ## ```
proc SciterNodeRemove*(hnode: HNODE; finalize: bool): INT {.importc, cdecl.}
  ## ```
  ##   remove the node from the DOM, use finalize=FALSE if you plan to attach the node to the DOM later.
  ## ```
proc SciterCreateTextNode*(text: LPCWSTR; textLength: cuint; phnode: ptr HNODE): INT {.
    importc, cdecl.}
  ## ```
  ##   ATTENTION: node handles returned by these two functions are AddRef'ed
  ## ```
proc SciterCreateCommentNode*(text: LPCWSTR; textLength: cuint; phnode: ptr HNODE): INT {.
    importc, cdecl.}
proc SciterAtomValue*(name: cstring): UINT64 {.importc, cdecl.}
proc SciterAtomNameCB*(atomv: UINT64; rcv: LPCSTR_RECEIVER; rcv_param: LPVOID): UINT64 {.
    importc, cdecl.}
proc SciterClassName*(): LPCWSTR {.importc, cdecl.}
  ## ```
  ##   Get name of Sciter window class.
  ##   
  ##    \return \b LPCWSTR, name of Sciter window class.
  ##            \b NULL if initialization of the engine failed, Direct2D or DirectWrite are not supported on the OS.
  ##   
  ##    Use this function if you wish to create unicode version of Sciter.
  ##    The returned name can be used in CreateWindow(Ex)W function.
  ##    You can use #SciterClassNameT macro.
  ## ```
proc SciterVersion*(major: bool): cuint {.importc, cdecl.}
  ## ```
  ##   Returns major and minor version of Sciter engine.
  ##     \return UINT, hiword (16-bit) contains major number and loword contains minor number;
  ## ```
proc SciterDataReady*(hwnd: ptr GtkWidget; uri: LPCWSTR; data: LPCBYTE;
                     dataLength: cuint): bool {.importc, cdecl.}
  ## ```
  ##   The Sciter Engine of Terra Informatica Software, Inc.
  ##    http:sciter.com
  ##    
  ##    The code and information provided "as-is" without
  ##    warranty of any kind, either expressed or implied.
  ##    
  ##    (C) 2003-2015, Terra Informatica Software, Inc.
  ##    
  ##     
  ##    Behaviors support (a.k.a windowless controls)
  ##    
  ##     This function is used in response to SCN_LOAD_DATA request.
  ##   
  ##    \param[in] hwnd \b HWINDOW, Sciter window handle.
  ##    \param[in] uri \b LPCWSTR, URI of the data requested by Sciter.
  ##    \param[in] data \b LPBYTE, pointer to data buffer.
  ##    \param[in] dataLength \b UINT, length of the data in bytes.
  ##    \return \b BOOL, TRUE if Sciter accepts the data or \c FALSE if error occured
  ##    (for example this function was called outside of #SCN_LOAD_DATA request).
  ##   
  ##    \warning If used, call of this function MUST be done ONLY while handling
  ##    SCN_LOAD_DATA request and in the same thread. For asynchronous resource loading
  ##    use SciterDataReadyAsync
  ## ```
proc SciterDataReadyAsync*(hwnd: ptr GtkWidget; uri: LPCWSTR; data: LPCBYTE;
                          dataLength: cuint; requestId: LPVOID): bool {.importc, cdecl.}
proc SciterLoadFile*(hWndSciter: ptr GtkWidget; url: LPCWSTR): bool {.importc, cdecl.}
  ## ```
  ##   Load HTML file.
  ##   
  ##    \param[in] hWndSciter \b HWINDOW, Sciter window handle.
  ##    \param[in] url \b LPCWSTR, either absolute URL of HTML file to load. "file:...", "http:...", "res:...", "this:app/..." or absolute file path.
  ##    \return \b BOOL, \c TRUE if the text was parsed and loaded successfully, \c FALSE otherwise.
  ## ```
proc SciterLoadHtml*(hWndSciter: ptr GtkWidget; html: LPCBYTE; htmlSize: cuint;
                    baseUrl: LPCWSTR): bool {.importc, cdecl.}
  ## ```
  ##   Load HTML from in memory buffer with base.
  ##   
  ##    \param[in] hWndSciter \b HWINDOW, Sciter window handle.
  ##    \param[in] html \b LPCBYTE, Address of HTML to load.
  ##    \param[in] htmlSize \b UINT, Length of the array pointed by html parameter.
  ##    \param[in] baseUrl \b LPCWSTR, base URL. All relative links will be resolved against
  ##                                   this URL.
  ##    \return \b BOOL, \c TRUE if the text was parsed and loaded successfully, FALSE otherwise.
  ## ```
proc SciterSetCallback*(hWndSciter: ptr GtkWidget; cb: LPSciterHostCallback;
                       cbParam: LPVOID): VOID {.importc, cdecl.}
  ## ```
  ##   Set \link #SCITER_NOTIFY() notification callback function \endlink.
  ##   
  ##    \param[in] hWndSciter \b HWINDOW, Sciter window handle.
  ##    \param[in] cb \b SCITER_NOTIFY*, \link #SCITER_NOTIFY() callback function \endlink.
  ##    \param[in] cbParam \b LPVOID, parameter that will be passed to \link #SCITER_NOTIFY() callback function \endlink as vParam paramter.
  ## ```
proc SciterSetMasterCSS*(utf8: LPCBYTE; numBytes: cuint): bool {.importc, cdecl.}
proc SciterAppendMasterCSS*(utf8: LPCBYTE; numBytes: cuint): bool {.importc, cdecl.}
proc SciterSetCSS*(hWndSciter: ptr GtkWidget; utf8: LPCBYTE; numBytes: cuint;
                  baseUrl: LPCWSTR; mediaType: LPCWSTR): bool {.importc, cdecl.}
proc SciterSetMediaType*(hWndSciter: ptr GtkWidget; mediaType: LPCWSTR): bool {.
    importc, cdecl.}
proc SciterSetMediaVars*(hWndSciter: ptr GtkWidget; mediaVars: ptr SCITER_VALUE): bool {.
    importc, cdecl.}
proc SciterGetMinWidth*(hWndSciter: ptr GtkWidget): cuint {.importc, cdecl.}
proc SciterGetMinHeight*(hWndSciter: ptr GtkWidget; width: cuint): cuint {.importc,
    cdecl.}
proc SciterCall*(hWnd: ptr GtkWidget; functionName: LPCSTR; argc: cuint;
                argv: ptr SCITER_VALUE; retval: ptr SCITER_VALUE): bool {.importc, cdecl.}
  ## ```
  ##   evalue script in context of current document
  ## ```
proc SciterEval*(hwnd: ptr GtkWidget; script: LPCWSTR; scriptLength: cuint;
                pretval: ptr SCITER_VALUE): bool {.importc, cdecl.}
  ## ```
  ##   evalue script in context of current document
  ## ```
proc SciterUpdateWindow*(hwnd: ptr GtkWidget): VOID {.importc, cdecl.}
  ## ```
  ##   Update pending changes in Sciter window.
  ##   
  ##    \param[in] hwnd \b HWINDOW, Sciter window handle.
  ## ```
proc SciterSetOption*(hWnd: ptr GtkWidget; option: cuint; value: UINT_PTR): bool {.
    importc, cdecl.}
proc SciterGetPPI*(hWndSciter: ptr GtkWidget; px: ptr cuint; py: ptr cuint): VOID {.
    importc, cdecl.}
proc SciterGetViewExpando*(hwnd: ptr GtkWidget; pval: ptr VALUE): bool {.importc, cdecl.}
proc SciterEnumUrlData*(hWndSciter: ptr GtkWidget; receiver: ptr URL_DATA_RECEIVER;
                       param: LPVOID; url: LPCSTR): bool {.importc, cdecl.}
  ## ```
  ##   Get graphics capabilities of the system
  ##   
  ##    \pcaps[in] LPUINT \b pcaps, address of variable receiving:
  ##                                0 - no compatible graphics found;
  ##                                1 - compatible graphics found but Direct2D will use WARP driver (software emulation);
  ##                                2 - Direct2D will use hardware backend (best performance);
  ##    \return \b BOOL, \c TRUE if pcaps is valid pointer.
  ## ```
proc SciterGraphicsCaps*(pcaps: LPUINT): bool {.importc, cdecl.}
proc SciterSetHomeURL*(hWndSciter: ptr GtkWidget; baseUrl: LPCWSTR): bool {.importc,
    cdecl.}
proc SciterCreateWindow*(creationFlags: cuint; frame: LPRECT;
                        delegate: SciterWindowDelegate; delegateParam: LPVOID;
                        parent: ptr GtkWidget): ptr GtkWidget {.importc, cdecl.}
  ## ```
  ##   Create sciter window.
  ##     On Windows returns HWND of either top-level or child window created.
  ##     On OS X returns NSView* of either top-level window or child view .
  ##   
  ##    \param[in] creationFlags \b SCITER_CREATE_WINDOW_FLAGS, creation flags.
  ##    \param[in] frame \b LPRECT, window frame position and size.
  ##    \param[in] delegate \b SciterWindowDelegate, either partial WinProc implementation or thing implementing NSWindowDelegate protocol.
  ##    \param[in] delegateParam \b LPVOID, optional param passed to SciterWindowDelegate.
  ##    \param[in] parent \b HWINDOW, optional parent window.
  ## ```
proc SciterSetupDebugOutput*(hwndOrNull: ptr GtkWidget; param: LPVOID;
                            pfOutput: DEBUG_OUTPUT_PROC): VOID {.importc, cdecl.}
{.pop.}
